{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/tslib/tslib.es6.js","webpack:///./src/adler32.ts","webpack:///./src/rawdeflate.ts","webpack:///./src/define/typedarray/hybrid.ts","webpack:///./src/bitstream.ts","webpack:///./src/zip.ts","webpack:///./src/crc32.ts","webpack:///./src/heap.ts","webpack:///./src/huffman.ts","webpack:///./src/rawinflate.ts","webpack:///./src/rawinflate_stream.ts","webpack:///./src/zlibt.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","extendStatics","b","setPrototypeOf","__proto__","Array","__extends","__","this","constructor","gCompressionType","adler32_Alder","Alder","update","adler","array","tlen","s1","s2","len","length","OptimizationParameter","Adler32","USE_TYPEDARRAY","Uint8Array","Uint16Array","Uint32Array","DataView","bitstream_BitStream","BitStream","buffer","bufferPosition","ReverseTable","getReverseTable","index","bitindex","DefaultBlockSize","Error","expandBuffer","oldbuf","il","uint8Buffer","set","arrayBuffer","writeBits","number","reverse","num","current","finish","output","subarray","table","CompressionMethod","OperatingSystem","Flags","rawdeflate_Lz77Match","Lz77Match","backwardDistance","code","getDistanceCode_","dist","toLz77Array","codeArray","pos","LengthCodeTable","rawdeflate_RawDeflate","RawDeflate","input","opt_params","compressionType","CompressionType","DYNAMIC","lazy","op","push","compress","blockArray","position","NONE","slice","makeNocompressBlock","FIXED","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","bfinal","btype","nlen","data","stream","lz77","fixedHuffman","hlit","hdist","hclen","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","bitlen","hclenOrder","transLengths","getLengths_","freqsLitLen","getCodesFromLengths_","freqsDist","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","literal","apply","FixedHuffmanTable","matchKey","matchList","longestMatch","prevMatch","tmp","windowSize","WindowSize","lz77buf","skipLength","writeMatch","match","offset","ilw","lz77Array","Lz77MinLength","shift","searchLongestMatch_","currentMatch","matchLength","j","matchMax","dl","permatch","Lz77MaxLength","litlenLengths","runLength","nResult","rpt","src","result","limit","nodes","values","codeLength","nSymbols","heap","zlibt_ZlibT","Heap","HUFMAX","pop","reversePackageMerge_","symbols","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","lengths","count","startCode","MaxCodeLength","crc32_CRC32","CRC32","calc","single","crc","Table","Table_","heap_Heap","getChild","getParent","parent","swap","huffman_Huffman","Huffman","buildHuffmanTable","size","bitLength","skip","reversed","rtemp","listSize","maxCodeLength","minCodeLength","Number","POSITIVE_INFINITY","rBufferType","zip_Zip","Zip","files","comment","addFile","compressed","crc32","DEFLATE","STORE","deflateWithOption","option","encrypted","setPassword","password","file","op1","op2","op3","endOfCentralDirectorySize","flags","compressionMethod","date","plainSize","filenameLength","extraFieldLength","commentLength","filename","extraField","jl","localFileSize","centralDirectorySize","createEncryptionKey","unshift","encode","Math","random","LocalFileHeaderSignature","FileHeaderSignature","needVersion","MSDOS","ENCRYPT","Date","getMinutes","getSeconds","getHours","getMonth","getDate","getFullYear","CentralDirectorySignature","getByte","updateKeys","keyOrigin","rStatus","rBlockType","rawinflate_RawInflate","RawInflate","bufferType","BufferType","ADAPTIVE","resize","blocks","bufferSize","ZLIB_RAW_INFLATE_BUFFER_SIZE","totalpos","ip","bitsbuf","bitsbuflen","BLOCK","MaxBackwardLength","MaxCopyLength","decompress","parseBlock","concatBufferBlock","concatBufferDynamic","hdr","readBits","parseUncompressedBlock","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","octet","readCodeByTable","codeWithLength","inputLength","codeTable","preCopy","olength","expandBufferBlock","expandBufferAdaptive","fixRatio","decodeHuffmanAdaptive","FixedLiteralLengthTable","FixedDistanceTable","decodeHuffmanBlock","codeLengthsTable","litlenTable","distTable","lengthTable","prev","repeat","codeLengths","Order","litlen","currentLitlenTable","ti","codeDist","lengthCodeTable","lengthExtraTable","LengthExtraTable","distCodeTable","DistCodeTable","distExtraTable","DistExtraTable","opt_param","backward","newSize","maxInflateSize","ratio","addRatio","block","ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE","rawinflate_stream_RawInflateStream","RawInflateStream","opt_buffersize","status","blockLength","sp","Status","INITIALIZED","ip_","bitsbuflen_","bitsbuf_","currentBlockType","BlockType","newInput","stop","BLOCK_HEADER_START","readBlockHeader","BLOCK_HEADER_END","BLOCK_BODY_START","UNCOMPRESSED","readUncompressedBlockHeader","BLOCK_BODY_END","DECODE_BLOCK_START","decodeHuffman","DECODE_BLOCK_END","concatBuffer","save_","restore_","_this","bits","parseDynamicHuffmanBlockImpl","e","ZlibT","_super","RESERVED"],"mappings":"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","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export class Alder {\r\n    public static OptimizationParameter = 1024;\r\n    constructor() {\r\n    \r\n    }\r\n    public static update(adler: number, array: Array<any> | Uint8Array) {\r\n        let s1 = adler & 0xffff;\r\n        let s2 = (adler >>> 16) & 0xffff;\r\n        let len = array.length;\r\n        let tlen;\r\n        let i = 0;\r\n    \r\n        while (len > 0) {\r\n        tlen = len > Alder.OptimizationParameter ?\r\n        Alder.OptimizationParameter : len;\r\n        len -= tlen;\r\n        do {\r\n            s1 += array[i++];\r\n            s2 += s1;\r\n        } while (--tlen);\r\n    \r\n        s1 %= 65521;\r\n        s2 %= 65521;\r\n        }\r\n        return ((s2 << 16) | s1) >>> 0;\r\n    }\r\n}\r\nexport const Adler32 = (array) => {\r\n    return Alder.update(1, array);\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { BitStream } from './bitstream';\r\nimport { ZlibT } from './zlibt';\r\n\r\nenum gCompressionType {\r\n    NONE= 0,\r\n    FIXED= 1,\r\n    DYNAMIC= 2,\r\n    RESERVED= 3\r\n}; \r\nexport class Lz77Match {\r\n    public length: number;\r\n    public backwardDistance: number;\r\n    \r\n    constructor(length: number, backwardDistance: number) {\r\n        this.length = length;\r\n        this.backwardDistance = backwardDistance;\r\n    }\r\n\r\n    static get LengthCodeTable() {\r\n        const code  = (length) => {\r\n            switch (true) {\r\n              case (length === 3): return [257, length - 3, 0]; break;\r\n              case (length === 4): return [258, length - 4, 0]; break;\r\n              case (length === 5): return [259, length - 5, 0]; break;\r\n              case (length === 6): return [260, length - 6, 0]; break;\r\n              case (length === 7): return [261, length - 7, 0]; break;\r\n              case (length === 8): return [262, length - 8, 0]; break;\r\n              case (length === 9): return [263, length - 9, 0]; break;\r\n              case (length === 10): return [264, length - 10, 0]; break;\r\n              case (length <= 12): return [265, length - 11, 1]; break;\r\n              case (length <= 14): return [266, length - 13, 1]; break;\r\n              case (length <= 16): return [267, length - 15, 1]; break;\r\n              case (length <= 18): return [268, length - 17, 1]; break;\r\n              case (length <= 22): return [269, length - 19, 2]; break;\r\n              case (length <= 26): return [270, length - 23, 2]; break;\r\n              case (length <= 30): return [271, length - 27, 2]; break;\r\n              case (length <= 34): return [272, length - 31, 2]; break;\r\n              case (length <= 42): return [273, length - 35, 3]; break;\r\n              case (length <= 50): return [274, length - 43, 3]; break;\r\n              case (length <= 58): return [275, length - 51, 3]; break;\r\n              case (length <= 66): return [276, length - 59, 3]; break;\r\n              case (length <= 82): return [277, length - 67, 4]; break;\r\n              case (length <= 98): return [278, length - 83, 4]; break;\r\n              case (length <= 114): return [279, length - 99, 4]; break;\r\n              case (length <= 130): return [280, length - 115, 4]; break;\r\n              case (length <= 162): return [281, length - 131, 5]; break;\r\n              case (length <= 194): return [282, length - 163, 5]; break;\r\n              case (length <= 226): return [283, length - 195, 5]; break;\r\n              case (length <= 257): return [284, length - 227, 5]; break;\r\n              case (length === 258): return [285, length - 258, 0]; break;\r\n              default: throw 'invalid length: ' + length;\r\n            }\r\n        }\r\n\r\n        let table = [];\r\n        let i = 0;\r\n        let c = [];\r\n\r\n        for (i = 3; i <= 258; i++) {\r\n            c = code(i);\r\n            table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\r\n        }\r\n\r\n        return USE_TYPEDARRAY ? new Uint32Array(table) : table;\r\n    }\r\n    public getDistanceCode_(dist: number) {\r\n        /** @type {!Array.<number>} distance code table. */\r\n        let r;\r\n      \r\n        switch (true) {\r\n          case (dist === 1): r = [0, dist - 1, 0]; break;\r\n          case (dist === 2): r = [1, dist - 2, 0]; break;\r\n          case (dist === 3): r = [2, dist - 3, 0]; break;\r\n          case (dist === 4): r = [3, dist - 4, 0]; break;\r\n          case (dist <= 6): r = [4, dist - 5, 1]; break;\r\n          case (dist <= 8): r = [5, dist - 7, 1]; break;\r\n          case (dist <= 12): r = [6, dist - 9, 2]; break;\r\n          case (dist <= 16): r = [7, dist - 13, 2]; break;\r\n          case (dist <= 24): r = [8, dist - 17, 3]; break;\r\n          case (dist <= 32): r = [9, dist - 25, 3]; break;\r\n          case (dist <= 48): r = [10, dist - 33, 4]; break;\r\n          case (dist <= 64): r = [11, dist - 49, 4]; break;\r\n          case (dist <= 96): r = [12, dist - 65, 5]; break;\r\n          case (dist <= 128): r = [13, dist - 97, 5]; break;\r\n          case (dist <= 192): r = [14, dist - 129, 6]; break;\r\n          case (dist <= 256): r = [15, dist - 193, 6]; break;\r\n          case (dist <= 384): r = [16, dist - 257, 7]; break;\r\n          case (dist <= 512): r = [17, dist - 385, 7]; break;\r\n          case (dist <= 768): r = [18, dist - 513, 8]; break;\r\n          case (dist <= 1024): r = [19, dist - 769, 8]; break;\r\n          case (dist <= 1536): r = [20, dist - 1025, 9]; break;\r\n          case (dist <= 2048): r = [21, dist - 1537, 9]; break;\r\n          case (dist <= 3072): r = [22, dist - 2049, 10]; break;\r\n          case (dist <= 4096): r = [23, dist - 3073, 10]; break;\r\n          case (dist <= 6144): r = [24, dist - 4097, 11]; break;\r\n          case (dist <= 8192): r = [25, dist - 6145, 11]; break;\r\n          case (dist <= 12288): r = [26, dist - 8193, 12]; break;\r\n          case (dist <= 16384): r = [27, dist - 12289, 12]; break;\r\n          case (dist <= 24576): r = [28, dist - 16385, 13]; break;\r\n          case (dist <= 32768): r = [29, dist - 24577, 13]; break;\r\n          default: throw 'invalid distance';\r\n        }\r\n        return r;\r\n    }\r\n    public toLz77Array() {\r\n        /** @type {number} */\r\n        let length = this.length;\r\n        /** @type {number} */\r\n        let dist = this.backwardDistance;\r\n        /** @type {Array} */\r\n        let codeArray = [];\r\n        /** @type {number} */\r\n        let pos = 0;\r\n        /** @type {!Array.<number>} */\r\n        let code;\r\n      \r\n        // length\r\n        code = Lz77Match.LengthCodeTable[length];\r\n        codeArray[pos++] = code & 0xffff;\r\n        codeArray[pos++] = (code >> 16) & 0xff;\r\n        codeArray[pos++] = code >> 24;\r\n      \r\n        // distance\r\n        code = this.getDistanceCode_(dist);\r\n        codeArray[pos++] = code[0];\r\n        codeArray[pos++] = code[1];\r\n        codeArray[pos++] = code[2];\r\n      \r\n        return codeArray;\r\n    };\r\n      \r\n}\r\nexport class RawDeflate {\r\n\r\n    public static CompressionType = gCompressionType; \r\n    public compressionType: gCompressionType;\r\n    public lazy: number;\r\n    public freqsLitLen: Array<any> | Uint32Array;\r\n    public freqsDist: Array<any> | Uint32Array;\r\n    public input: Array<number> | Uint8Array;\r\n    public output: Array<number> | Uint8Array;\r\n    public op: number;\r\n    public length: number;\r\n    public backwardDistance: number;\r\n    \r\n    public static Lz77MaxLength = 258;\r\n\r\n    public static WindowSize = 0x8000;\r\n\r\n    public static MaxCodeLength = 16;\r\n\r\n    public static HUFMAX = 286;\r\n\r\n    public static Lz77MinLength = 3;\r\n    constructor(input: Array<number> | Uint8Array, opt_params: any) {\r\n        this.compressionType = RawDeflate.CompressionType.DYNAMIC;\r\n        this.lazy = 0;\r\n        this.input =\r\n        (USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;\r\n        this.op = 0;\r\n\r\n        // option parameters\r\n        if (opt_params) {\r\n            if (opt_params['lazy']) {\r\n                this.lazy = opt_params['lazy'];\r\n            }\r\n            if (typeof opt_params['compressionType'] === 'number') {\r\n                this.compressionType = opt_params['compressionType'];\r\n            }\r\n            if (opt_params['outputBuffer']) {\r\n                this.output =\r\n                (USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?\r\n                new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\r\n            }\r\n            if (typeof opt_params['outputIndex'] === 'number') {\r\n                this.op = opt_params['outputIndex'];\r\n            }\r\n        }\r\n        if (!this.output) {\r\n            this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\r\n        }\r\n    }\r\n\r\n    public static get FixedHuffmanTable() {\r\n        let table = [], i;\r\n      \r\n        for (i = 0; i < 288; i++) {\r\n          switch (true) {\r\n            case (i <= 143): table.push([i       + 0x030, 8]); break;\r\n            case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\r\n            case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\r\n            case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\r\n            default:\r\n              throw 'invalid literal: ' + i;\r\n          }\r\n        }\r\n        return table;\r\n    }\r\n\r\n    public compress() {\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let blockArray;\r\n        /** @type {number} */\r\n        let position;\r\n        /** @type {number} */\r\n        let length;\r\n        let input = this.input;\r\n      \r\n        // compression\r\n        switch (this.compressionType) {\r\n          case RawDeflate.CompressionType.NONE:\r\n            // each 65535-Byte (length header: 16-bit)\r\n            for (position = 0, length = input.length; position < length;) {\r\n              blockArray = USE_TYPEDARRAY ?\r\n                (<Uint8Array>input).subarray(position, position + 0xffff) :\r\n                input.slice(position, position + 0xffff);\r\n              position += blockArray.length;\r\n              this.makeNocompressBlock(blockArray, (position === length));\r\n            }\r\n            break;\r\n          case RawDeflate.CompressionType.FIXED:\r\n            this.output = this.makeFixedHuffmanBlock(input, true);\r\n            this.op = this.output.length;\r\n            break;\r\n          case RawDeflate.CompressionType.DYNAMIC:\r\n            this.output = this.makeDynamicHuffmanBlock(input, true);\r\n            this.op = this.output.length;\r\n            break;\r\n          default:\r\n            throw 'invalid compression type';\r\n        }\r\n        return this.output;\r\n    }\r\n\r\n    public makeNocompressBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {number} */\r\n        let len;\r\n        /** @type {number} */\r\n        let nlen;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n\r\n        let output = this.output;\r\n        let op = this.op;\r\n\r\n        // expand buffer\r\n        if (USE_TYPEDARRAY) {\r\n            output = new Uint8Array((<Uint8Array>this.output).buffer);\r\n            while (output.length <= op + blockArray.length + 5) {\r\n            output = new Uint8Array(output.length << 1);\r\n            }\r\n            output.set(this.output);\r\n        }\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.NONE;\r\n        output[op++] = (bfinal) | (btype << 1);\r\n\r\n        // length\r\n        len = blockArray.length;\r\n        nlen = (~len + 0x10000) & 0xffff;\r\n        output[op++] =          len & 0xff;\r\n        output[op++] =  (len >>> 8) & 0xff;\r\n        output[op++] =         nlen & 0xff;\r\n        output[op++] = (nlen >>> 8) & 0xff;\r\n\r\n        // copy buffer\r\n        if (USE_TYPEDARRAY) {\r\n            (<Uint8Array>output).set(blockArray, op);\r\n            op += blockArray.length;\r\n            output = (<Uint8Array>output).subarray(0, op);\r\n        } else {\r\n            for (i = 0, il = blockArray.length; i < il; ++i) {\r\n            output[op++] = blockArray[i];\r\n            }\r\n            (<Array<number>>output).length = op;\r\n        }\r\n\r\n        this.op = op;\r\n        this.output = output;\r\n\r\n        return output;\r\n    }\r\n\r\n    public makeFixedHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {Zlib.BitStream} */\r\n        let stream = new BitStream(USE_TYPEDARRAY ?\r\n            new Uint8Array((<Uint8Array>this.output).buffer) : this.output, this.op);\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let data;\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.FIXED;\r\n\r\n        stream.writeBits(bfinal, 1, true);\r\n        stream.writeBits(btype, 2, true);\r\n\r\n        data = this.lz77(blockArray);\r\n        this.fixedHuffman(data, stream);\r\n\r\n        return stream.finish();\r\n    }\r\n\r\n    public makeDynamicHuffmanBlock(blockArray: Array<number> | Uint8Array, isFinalBlock: boolean) {\r\n        /** @type {Zlib.BitStream} */\r\n        let stream = new BitStream(USE_TYPEDARRAY ?\r\n            new Uint8Array((<Uint8Array>this.output).buffer) : this.output, this.op);\r\n        /** @type {number} */\r\n        let bfinal;\r\n        /** @type {Zlib.RawDeflate.CompressionType} */\r\n        let btype;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let data;\r\n        /** @type {number} */\r\n        let hlit;\r\n        /** @type {number} */\r\n        let hdist;\r\n        /** @type {number} */\r\n        let hclen;\r\n        /** @const @type {Array.<number>} */\r\n        let hclenOrder =\r\n                [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let litLenLengths;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let litLenCodes;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let distLengths;\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let distCodes;\r\n        /** @type {{\r\n         *   codes: !(Array.<number>|Uint32Array),\r\n         *   freqs: !(Array.<number>|Uint8Array)\r\n         * }} */\r\n        let treeSymbols;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let treeLengths;\r\n        /** @type {Array} */\r\n        let transLengths = new Array(19);\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let treeCodes;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let bitlen;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n\r\n        // header\r\n        bfinal = isFinalBlock ? 1 : 0;\r\n        btype = RawDeflate.CompressionType.DYNAMIC;\r\n\r\n        stream.writeBits(bfinal, 1, true);\r\n        stream.writeBits(btype, 2, true);\r\n\r\n        data = this.lz77(blockArray);\r\n\r\n        litLenLengths = this.getLengths_(this.freqsLitLen, 15);\r\n        litLenCodes = this.getCodesFromLengths_(litLenLengths);\r\n        distLengths = this.getLengths_(this.freqsDist, 7);\r\n        distCodes = this.getCodesFromLengths_(distLengths);\r\n\r\n        for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\r\n        for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\r\n\r\n        // HCLEN\r\n        treeSymbols =\r\n            this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\r\n        treeLengths = this.getLengths_(treeSymbols.freqs, 7);\r\n        for (i = 0; i < 19; i++) {\r\n            transLengths[i] = treeLengths[hclenOrder[i]];\r\n        }\r\n        for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\r\n\r\n        treeCodes = this.getCodesFromLengths_(treeLengths);\r\n\r\n        // 出力\r\n        stream.writeBits(hlit - 257, 5, true);\r\n        stream.writeBits(hdist - 1, 5, true);\r\n        stream.writeBits(hclen - 4, 4, true);\r\n        for (i = 0; i < hclen; i++) {\r\n            stream.writeBits(transLengths[i], 3, true);\r\n        }\r\n\r\n        // ツリーの出力\r\n        for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\r\n            code = treeSymbols.codes[i];\r\n\r\n            stream.writeBits(treeCodes[code], treeLengths[code], true);\r\n\r\n            // extra bits\r\n            if (code >= 16) {\r\n            i++;\r\n            switch (code) {\r\n                case 16: bitlen = 2; break;\r\n                case 17: bitlen = 3; break;\r\n                case 18: bitlen = 7; break;\r\n                default:\r\n                throw 'invalid code: ' + code;\r\n            }\r\n\r\n            stream.writeBits(treeSymbols.codes[i], bitlen, true);\r\n            }\r\n        }\r\n\r\n        this.dynamicHuffman(\r\n            data,\r\n            [litLenCodes, litLenLengths],\r\n            [distCodes, distLengths],\r\n            stream\r\n        );\r\n\r\n        return stream.finish();\r\n    };\r\n\r\n    public dynamicHuffman(dataArray: Array<number>|Uint16Array, litLen: any[], dist: any[], stream: any) {\r\n        /** @type {number} */\r\n        let index;\r\n        /** @type {number} */\r\n        let length;\r\n        /** @type {number} */\r\n        let literal;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let litLenCodes;\r\n        /** @type {number} */\r\n        let litLenLengths;\r\n        /** @type {number} */\r\n        let distCodes;\r\n        /** @type {number} */\r\n        let distLengths;\r\n\r\n        litLenCodes = litLen[0];\r\n        litLenLengths = litLen[1];\r\n        distCodes = dist[0];\r\n        distLengths = dist[1];\r\n\r\n        // 符号を BitStream に書き込んでいく\r\n        for (index = 0, length = dataArray.length; index < length; ++index) {\r\n            literal = dataArray[index];\r\n\r\n            // literal or length\r\n            stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\r\n\r\n            // 長さ・距離符号\r\n            if (literal > 256) {\r\n            // length extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // distance\r\n            code = dataArray[++index];\r\n            stream.writeBits(distCodes[code], distLengths[code], true);\r\n            // distance extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // 終端\r\n            } else if (literal === 256) {\r\n            break;\r\n            }\r\n        }\r\n\r\n        return stream;\r\n    }\r\n\r\n    public fixedHuffman(dataArray: Array<number> | Uint16Array, stream: BitStream) {\r\n        /** @type {number} */\r\n        let index;\r\n        /** @type {number} */\r\n        let length;\r\n        /** @type {number} */\r\n        let literal;\r\n      \r\n        // 符号を BitStream に書き込んでいく\r\n        for (index = 0, length = dataArray.length; index < length; index++) {\r\n          literal = dataArray[index];\r\n      \r\n          BitStream.prototype.writeBits.apply(\r\n              stream, RawDeflate.FixedHuffmanTable[literal]\r\n        )\r\n          // 長さ・距離符号\r\n          if (literal > 0x100) {\r\n            // length extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n            // distance\r\n            stream.writeBits(dataArray[++index], 5);\r\n            // distance extra\r\n            stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n          // 終端\r\n          } else if (literal === 0x100) {\r\n            break;\r\n          }\r\n        }\r\n        return stream;\r\n    }\r\n    public lz77(dataArray: Array<number>|Uint8Array) {\r\n        /** @type {number} input position */\r\n        let position;\r\n        /** @type {number} input length */\r\n        let length;\r\n        /** @type {number} loop counter */\r\n        let i;\r\n        /** @type {number} loop limiter */\r\n        let il;\r\n        /** @type {number} chained-hash-table key */\r\n        let matchKey;\r\n        /** @type {Object.<number, Array.<number>>} chained-hash-table */\r\n        let table = {};\r\n        /** @const @type {number} */\r\n        let windowSize = RawDeflate.WindowSize;\r\n        /** @type {Array.<number>} match list */\r\n        let matchList;\r\n        /** @type {Zlib.RawDeflate.Lz77Match} longest match */\r\n        let longestMatch;\r\n        /** @type {Zlib.RawDeflate.Lz77Match} previous longest match */\r\n        let prevMatch;\r\n        /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\r\n        let lz77buf = USE_TYPEDARRAY ?\r\n          new Uint16Array(dataArray.length * 2) : [];\r\n        /** @type {number} lz77 output buffer pointer */\r\n        let pos = 0;\r\n        /** @type {number} lz77 skip length */\r\n        let skipLength = 0;\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array )(286);\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array) (30);\r\n        /** @type {number} */\r\n        let lazy = this.lazy;\r\n        /** @type {*} temporary letiable */\r\n        let tmp;\r\n      \r\n        // 初期化\r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }\r\n          for (i = 0; i <= 29;) { freqsDist[i++] = 0; }\r\n        }\r\n        freqsLitLen[256] = 1; // EOB の最低出現回数は 1\r\n      \r\n        /**\r\n         * マッチデータの書き込み\r\n         * @param {Zlib.RawDeflate.Lz77Match} match LZ77 Match data.\r\n         * @param {!number} offset スキップ開始位置(相対指定).\r\n         * @private\r\n         */\r\n        const writeMatch = (match: Lz77Match, offset: number) => {\r\n            let lz77Array = match.toLz77Array();\r\n            /** @type {number} */\r\n            let iw = 0;\r\n            /** @type {number} */\r\n            let ilw = 0;\r\n        \r\n            for (iw = 0, ilw = lz77Array.length; iw < ilw; ++i) {\r\n                lz77buf[pos++] = lz77Array[i];\r\n            }\r\n            freqsLitLen[lz77Array[0]]++;\r\n            freqsDist[lz77Array[3]]++;\r\n            skipLength = match.length + offset - 1;\r\n            prevMatch = null;\r\n        }\r\n      \r\n        // LZ77 符号化\r\n        for (position = 0, length = dataArray.length; position < length; ++position) {\r\n          // ハッシュキーの作成\r\n          for (matchKey = 0, i = 0, il = RawDeflate.Lz77MinLength; i < il; ++i) {\r\n            if (position + i === length) {\r\n              break;\r\n            }\r\n            matchKey = (matchKey << 8) | dataArray[position + i];\r\n          }\r\n      \r\n          // テーブルが未定義だったら作成する\r\n          if (table[matchKey] === void 0) { table[matchKey] = []; }\r\n          matchList = table[matchKey];\r\n      \r\n          // skip\r\n          if (skipLength-- > 0) {\r\n            matchList.push(position);\r\n            continue;\r\n          }\r\n      \r\n          // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)\r\n          while (matchList.length > 0 && position - matchList[0] > windowSize) {\r\n            matchList.shift();\r\n          }\r\n      \r\n          // データ末尾でマッチしようがない場合はそのまま流しこむ\r\n          if (position + RawDeflate.Lz77MinLength >= length) {\r\n            if (prevMatch) {\r\n              writeMatch(prevMatch, -1);\r\n            }\r\n      \r\n            for (i = 0, il = length - position; i < il; ++i) {\r\n              tmp = dataArray[position + i];\r\n              lz77buf[pos++] = tmp;\r\n              ++freqsLitLen[tmp];\r\n            }\r\n            break;\r\n          }\r\n      \r\n          // マッチ候補から最長のものを探す\r\n          if (matchList.length > 0) {\r\n            longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\r\n      \r\n            if (prevMatch) {\r\n              // 現在のマッチの方が前回のマッチよりも長い\r\n              if (prevMatch.length < longestMatch.length) {\r\n                // write previous literal\r\n                tmp = dataArray[position - 1];\r\n                lz77buf[pos++] = tmp;\r\n                ++freqsLitLen[tmp];\r\n      \r\n                // write current match\r\n                writeMatch(longestMatch, 0);\r\n              } else {\r\n                // write previous match\r\n                writeMatch(prevMatch, -1);\r\n              }\r\n            } else if (longestMatch.length < lazy) {\r\n              prevMatch = longestMatch;\r\n            } else {\r\n              writeMatch(longestMatch, 0);\r\n            }\r\n          // 前回マッチしていて今回マッチがなかったら前回のを採用\r\n          } else if (prevMatch) {\r\n            writeMatch(prevMatch, -1);\r\n          } else {\r\n            tmp = dataArray[position];\r\n            lz77buf[pos++] = tmp;\r\n            ++freqsLitLen[tmp];\r\n          }\r\n      \r\n          matchList.push(position); // マッチテーブルに現在の位置を保存\r\n        }\r\n      \r\n        // 終端処理\r\n        lz77buf[pos++] = 256;\r\n        freqsLitLen[256]++;\r\n        this.freqsLitLen = freqsLitLen;\r\n        this.freqsDist = freqsDist;\r\n      \r\n        return /** @type {!(Uint16Array|Array.<number>)} */ (\r\n          USE_TYPEDARRAY ?  (<Uint16Array>lz77buf).subarray(0, pos) : lz77buf\r\n        );\r\n    }\r\n    \r\n    public searchLongestMatch_(data: any, position: number, matchList: Array<number>) {\r\n        let match,\r\n            currentMatch,\r\n            matchMax = 0, matchLength,\r\n            i, j, l, dl = data.length;\r\n\r\n        // 候補を後ろから 1 つずつ絞り込んでゆく\r\n        permatch:\r\n        for (i = 0, l = matchList.length; i < l; i++) {\r\n            match = matchList[l - i - 1];\r\n            matchLength = RawDeflate.Lz77MinLength;\r\n\r\n            // 前回までの最長一致を末尾から一致検索する\r\n            if (matchMax > RawDeflate.Lz77MinLength) {\r\n            for (j = matchMax; j > RawDeflate.Lz77MinLength; j--) {\r\n                if (data[match + j - 1] !== data[position + j - 1]) {\r\n                continue permatch;\r\n                }\r\n            }\r\n            matchLength = matchMax;\r\n            }\r\n\r\n            // 最長一致探索\r\n            while (matchLength < RawDeflate.Lz77MaxLength &&\r\n                position + matchLength < dl &&\r\n                data[match + matchLength] === data[position + matchLength]) {\r\n            ++matchLength;\r\n            }\r\n\r\n            // マッチ長が同じ場合は後方を優先\r\n            if (matchLength > matchMax) {\r\n            currentMatch = match;\r\n            matchMax = matchLength;\r\n            }\r\n\r\n            // 最長が確定したら後の処理は省略\r\n            if (matchLength === RawDeflate.Lz77MaxLength) {\r\n            break;\r\n            }\r\n        }\r\n        return new Lz77Match(matchMax, position - currentMatch);\r\n    }\r\n\r\n    public getTreeSymbols_(hlit: number, \r\n        litlenLengths: Array<number> | Uint8Array,\r\n        hdist: number,\r\n        distLengths: Array<number> | Uint8Array) {\r\n        \r\n        let src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\r\n        i, j, runLength, l,\r\n        result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\r\n        nResult,\r\n        rpt,\r\n        freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\r\n\r\n        j = 0;\r\n        for (i = 0; i < hlit; i++) {\r\n            src[j++] = litlenLengths[i];\r\n        }\r\n        for (i = 0; i < hdist; i++) {\r\n            src[j++] = distLengths[i];\r\n        }\r\n\r\n        if (!USE_TYPEDARRAY) {\r\n            for (i = 0, l = freqs.length; i < l; ++i) {\r\n            freqs[i] = 0;\r\n            }\r\n        }\r\n\r\n        nResult = 0;\r\n        for (i = 0, l = src.length; i < l; i += j) {\r\n            for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\r\n\r\n            runLength = j;\r\n\r\n            if (src[i] === 0) {\r\n            if (runLength < 3) {\r\n                while (runLength-- > 0) {\r\n                result[nResult++] = 0;\r\n                freqs[0]++;\r\n                }\r\n            } else {\r\n                while (runLength > 0) {\r\n                rpt = (runLength < 138 ? runLength : 138);\r\n\r\n                if (rpt > runLength - 3 && rpt < runLength) {\r\n                    rpt = runLength - 3;\r\n                }\r\n\r\n                if (rpt <= 10) {\r\n                    result[nResult++] = 17;\r\n                    result[nResult++] = rpt - 3;\r\n                    freqs[17]++;\r\n                } else {\r\n                    result[nResult++] = 18;\r\n                    result[nResult++] = rpt - 11;\r\n                    freqs[18]++;\r\n                }\r\n\r\n                runLength -= rpt;\r\n                }\r\n            }\r\n            } else {\r\n            result[nResult++] = src[i];\r\n            freqs[src[i]]++;\r\n            runLength--;\r\n\r\n                if (runLength < 3) {\r\n                    while (runLength-- > 0) {\r\n                    result[nResult++] = src[i];\r\n                    freqs[src[i]]++;\r\n                    }\r\n                } else {\r\n                    while (runLength > 0) {\r\n                    rpt = (runLength < 6 ? runLength : 6);\r\n\r\n                    if (rpt > runLength - 3 && rpt < runLength) {\r\n                        rpt = runLength - 3;\r\n                    }\r\n\r\n                    result[nResult++] = 16;\r\n                    result[nResult++] = rpt - 3;\r\n                    freqs[16]++;\r\n\r\n                    runLength -= rpt;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return {\r\n            codes:\r\n            USE_TYPEDARRAY ? (<Uint32Array>result).subarray(0, nResult) : result.slice(0, nResult),\r\n            freqs: freqs\r\n        };\r\n    }\r\n    public getLengths_(freqs: Array<number>|Uint8Array|Uint32Array, limit: number) {\r\n        /** @type {number} */\r\n        let nSymbols = freqs.length;\r\n        /** @type {Zlib.Heap} */\r\n        let heap = new ZlibT.Heap(2 * ZlibT.RawDeflate.HUFMAX);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\r\n        /** @type {Array} */\r\n        let nodes;\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        let values;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let codeLength;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n      \r\n        // 配列の初期化\r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = 0; i < nSymbols; i++) {\r\n            length[i] = 0;\r\n          }\r\n        }\r\n      \r\n        // ヒープの構築\r\n        for (i = 0; i < nSymbols; ++i) {\r\n          if (freqs[i] > 0) {\r\n            heap.push(i, freqs[i]);\r\n          }\r\n        }\r\n        nodes = new Array(heap.length / 2);\r\n        values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\r\n      \r\n        // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了\r\n        if (nodes.length === 1) {\r\n          length[heap.pop().index] = 1;\r\n          return length;\r\n        }\r\n      \r\n        // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定\r\n        for (i = 0, il = heap.length / 2; i < il; ++i) {\r\n          nodes[i] = heap.pop();\r\n          values[i] = nodes[i].value;\r\n        }\r\n        codeLength = this.reversePackageMerge_(values, values.length, limit);\r\n      \r\n        for (i = 0, il = nodes.length; i < il; ++i) {\r\n          length[nodes[i].index] = codeLength[i];\r\n        }\r\n      \r\n        return length;\r\n    }\r\n\r\n    public reversePackageMerge_(freqs: Array<number>|Uint32Array, symbols: number, limit: number) {\r\n        /** @type {!(Array.<number>|Uint16Array)} */\r\n        let minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\r\n        /** @type {Array} */\r\n        let value = new Array(limit);\r\n        /** @type {Array} */\r\n        let type  = new Array(limit);\r\n        /** @type {Array.<number>} */\r\n        let currentPosition = new Array(limit);\r\n        /** @type {number} */\r\n        let excess = (1 << limit) - symbols;\r\n        /** @type {number} */\r\n        let half = (1 << (limit - 1));\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let j;\r\n        /** @type {number} */\r\n        let t;\r\n        /** @type {number} */\r\n        let weight;\r\n        /** @type {number} */\r\n        let next;\r\n      \r\n        /**\r\n         * @param {number} j\r\n         */\r\n        const takePackage = ( index: number) => {\r\n          /** @type {number} */\r\n          let x = type[index][currentPosition[index]];\r\n      \r\n          if (x === symbols) {\r\n            takePackage(index+1);\r\n            takePackage(index+1);\r\n          } else {\r\n            --codeLength[x];\r\n          }\r\n      \r\n          ++currentPosition[index];\r\n        }\r\n      \r\n        minimumCost[limit-1] = symbols;\r\n      \r\n        for (j = 0; j < limit; ++j) {\r\n          if (excess < half) {\r\n            flag[j] = 0;\r\n          } else {\r\n            flag[j] = 1;\r\n            excess -= half;\r\n          }\r\n          excess <<= 1;\r\n          minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\r\n        }\r\n        minimumCost[0] = flag[0];\r\n      \r\n        value[0] = new Array(minimumCost[0]);\r\n        type[0]  = new Array(minimumCost[0]);\r\n        for (j = 1; j < limit; ++j) {\r\n          if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\r\n            minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\r\n          }\r\n          value[j] = new Array(minimumCost[j]);\r\n          type[j]  = new Array(minimumCost[j]);\r\n        }\r\n      \r\n        for (i = 0; i < symbols; ++i) {\r\n          codeLength[i] = limit;\r\n        }\r\n      \r\n        for (t = 0; t < minimumCost[limit-1]; ++t) {\r\n          value[limit-1][t] = freqs[t];\r\n          type[limit-1][t]  = t;\r\n        }\r\n      \r\n        for (i = 0; i < limit; ++i) {\r\n          currentPosition[i] = 0;\r\n        }\r\n        if (flag[limit-1] === 1) {\r\n          --codeLength[0];\r\n          ++currentPosition[limit-1];\r\n        }\r\n      \r\n        for (j = limit-2; j >= 0; --j) {\r\n          i = 0;\r\n          weight = 0;\r\n          next = currentPosition[j+1];\r\n      \r\n          for (t = 0; t < minimumCost[j]; t++) {\r\n            weight = value[j+1][next] + value[j+1][next+1];\r\n      \r\n            if (weight > freqs[i]) {\r\n              value[j][t] = weight;\r\n              type[j][t] = symbols;\r\n              next += 2;\r\n            } else {\r\n              value[j][t] = freqs[i];\r\n              type[j][t] = i;\r\n              ++i;\r\n            }\r\n          }\r\n      \r\n          currentPosition[j] = 0;\r\n          if (flag[j] === 1) {\r\n            takePackage(j);\r\n          }\r\n        }\r\n      \r\n        return codeLength;\r\n    };\r\n    public getCodesFromLengths_(lengths: Uint16Array | Array<number>) {\r\n        let codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\r\n            count = [],\r\n            startCode = [],\r\n            code = 0, i, il, j, m;\r\n      \r\n        // Count the codes of each length.\r\n        for (i = 0, il = lengths.length; i < il; i++) {\r\n          count[lengths[i]] = (count[lengths[i]] | 0) + 1;\r\n        }\r\n      \r\n        // Determine the starting code for each length block.\r\n        for (i = 1, il = RawDeflate.MaxCodeLength; i <= il; i++) {\r\n          startCode[i] = code;\r\n          code += count[i] | 0;\r\n          code <<= 1;\r\n        }\r\n      \r\n        // Determine the code for each symbol. Mirrored, of course.\r\n        for (i = 0, il = lengths.length; i < il; i++) {\r\n          code = startCode[lengths[i]];\r\n          startCode[lengths[i]] += 1;\r\n          codes[i] = 0;\r\n      \r\n          for (j = 0, m = lengths[i]; j < m; j++) {\r\n            codes[i] = (codes[i] << 1) | (code & 1);\r\n            code >>>= 1;\r\n          }\r\n        }\r\n      \r\n        return codes;\r\n      };\r\n}\r\n","export const USE_TYPEDARRAY =\r\n  (typeof Uint8Array !== 'undefined') &&\r\n  (typeof Uint16Array !== 'undefined') &&\r\n  (typeof Uint32Array !== 'undefined') &&\r\n  (typeof DataView !== 'undefined');\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport class BitStream {\r\n    public static DefaultBlockSize = 0x8000;\r\n    public index: number;\r\n    public bitindex: number;\r\n    public buffer: any;\r\n    public static ReverseTable: Uint8Array | any[];\r\n\r\n    constructor(buffer: Uint8Array | Array<any>, bufferPosition: number) {\r\n        BitStream.ReverseTable = this.getReverseTable();\r\n        this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\r\n        this.bitindex = 0;\r\n        this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ?\r\n          buffer :\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(BitStream.DefaultBlockSize);\r\n      \r\n        if (this.buffer.length * 2 <= this.index) {\r\n          throw new Error('invalid index');\r\n        } else if (this.buffer.length <= this.index) {\r\n          this.expandBuffer();\r\n        }\r\n    }\r\n\r\n    public expandBuffer() {\r\n        let oldbuf = this.buffer;\r\n        let i = 0;\r\n        let il = oldbuf.length;\r\n        let buffer: Uint8Array | Array<any> = new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\r\n        // copy buffer\r\n        if(USE_TYPEDARRAY) {\r\n            let uint8Buffer = new Uint8Array(il << 1);\r\n            uint8Buffer.set(oldbuf);\r\n            return (this.buffer = uint8Buffer); \r\n        } else {\r\n            let arrayBuffer = new Array(il << 1);\r\n            for (i = 0; i < il; ++i) {\r\n                arrayBuffer[i] = oldbuf[i];\r\n            }\r\n            return (this.buffer = arrayBuffer);\r\n        }\r\n      }\r\n\r\n    public writeBits(number: number, n: number, reverse?: boolean) {\r\n        let buffer = this.buffer;\r\n        let index = this.index;\r\n        let bitindex =this.bitindex;\r\n\r\n        let current = buffer[index];\r\n        let i;\r\n\r\n        const rev32_ = ( num: number) => {\r\n            return (BitStream.ReverseTable[num & 0xFF] << 24) |\r\n            (BitStream.ReverseTable[num >>> 8 & 0xFF] << 16) |\r\n            (BitStream.ReverseTable[num >>> 16 & 0xFF] << 8) |\r\n            BitStream.ReverseTable[num >>> 24 & 0xFF];\r\n        }\r\n\r\n        if (reverse && n > 1) {\r\n            number = n > 8 ?\r\n            rev32_(number) >> (32 - n) :\r\n            BitStream.ReverseTable[number] >> (8 - n);\r\n        }\r\n\r\n        if (n + bitindex < 8) {\r\n            current = (current << n) | number;\r\n            bitindex += n;\r\n        } else {\r\n            for (i = 0; i < n; ++i){\r\n            current = (current << 1) | ((number >> n - i - 1) & 1);\r\n\r\n            // next byte\r\n            if (++bitindex === 8) {\r\n                bitindex = 0;\r\n                buffer[index++] = BitStream.ReverseTable[current];\r\n                current = 0;\r\n\r\n                // expand\r\n                if (index === buffer.length) {\r\n                buffer = this.expandBuffer();\r\n                }\r\n            }\r\n            }\r\n        }\r\n        buffer[index] = current;\r\n        this.buffer = buffer;\r\n        this.bitindex = bitindex;\r\n        this.index = index;\r\n    }\r\n   \r\n    public finish () {\r\n        let buffer = this.buffer;\r\n        let index = this.index;\r\n        let output: any = null;\r\n        \r\n        if (this.bitindex > 0) {\r\n                buffer[index] <<= 8 - this.bitindex;\r\n                buffer[index] = BitStream.ReverseTable[buffer[index]];\r\n                index++;\r\n        }\r\n        // array truncation\r\n        if (USE_TYPEDARRAY) {\r\n            output = buffer.subarray(0, index);\r\n        } else {\r\n            buffer.length = index;\r\n                output = buffer;\r\n        }\r\n        return output;\r\n    }\r\n    private getReverseTable() {\r\n        let table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\r\n        let i = 0;\r\n           \r\n        for (; i < 256; ++i) {\r\n            table[i] = ((n) => {\r\n                let r = n;\r\n                let s = 7;\r\n                for (n >>>= 1; n; n >>>= 1) {\r\n                    r <<= 1;\r\n                    r |= n & 1;\r\n                    --s;\r\n                }\r\n                return (r << s & 0xff) >>> 0;\r\n            })(i);\r\n        }\r\n        return table;\r\n    }\r\n}\r\n","import { ZlibT } from './zlibt';\r\nimport { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport enum CompressionMethod {\r\n    STORE=   0,\r\n    DEFLATE= 8\r\n};\r\n  \r\nexport enum OperatingSystem {\r\n    MSDOS=  0,\r\n    UNIX=   3,\r\n    MACINTOSH= 7\r\n};\r\n  \r\nexport enum Flags {\r\n    ENCRYPT=    0x0001,\r\n    DESCRIPTOR= 0x0008,\r\n    UTF8=       0x0800\r\n};\r\n  \r\nexport class Zip {\r\n\r\n    public files = [];\r\n    public comment: Array<number>|Uint8Array;\r\n    public password: Array<number>|Uint8Array;\r\n    public static CompressionMethod = CompressionMethod;\r\n    public static OperatingSystem = OperatingSystem;\r\n    public static Flags = Flags;\r\n    constructor(opt_params: any) {\r\n        opt_params = opt_params || {};\r\n        this.files = [];\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        this.comment = opt_params['comment'];\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n    }\r\n\r\n    public static FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\r\n\r\n    public static LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\r\n\r\n    public static CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\r\n\r\n    public addFile(input: Array<number> | Uint8Array, opt_params: any) {\r\n        opt_params = opt_params || {};\r\n        /** @type {string} */\r\n        let filename = '' || opt_params['filename'];\r\n        /** @type {boolean} */\r\n        let compressed;\r\n        /** @type {number} */\r\n        let size = input.length;\r\n        /** @type {number} */\r\n        let crc32 = 0;\r\n      \r\n        if (USE_TYPEDARRAY && input instanceof Array) {\r\n          input = new Uint8Array(input);\r\n        }\r\n      \r\n        // default\r\n        if (typeof opt_params['compressionMethod'] !== 'number') {\r\n          opt_params['compressionMethod'] = Zip.CompressionMethod.DEFLATE;\r\n        }\r\n      \r\n        // その場で圧縮する場合\r\n        if (opt_params['compress']) {\r\n          switch (opt_params['compressionMethod']) {\r\n            case Zip.CompressionMethod.STORE:\r\n              break;\r\n            case Zip.CompressionMethod.DEFLATE:\r\n              crc32 = ZlibT.CRC32.calc(input);\r\n              input = this.deflateWithOption(input, opt_params);\r\n              compressed = true;\r\n              break;\r\n            default:\r\n              throw new Error('unknown compression method:' + opt_params['compressionMethod']);\r\n          }\r\n        }\r\n      \r\n        this.files.push({\r\n          buffer: input,\r\n          option: opt_params,\r\n          compressed: compressed,\r\n          encrypted: false,\r\n          size: size,\r\n          crc32: crc32\r\n        });\r\n    }\r\n\r\n    public setPassword(password: Array<number>|Uint8Array) {\r\n        this.password = password;\r\n    }\r\n\r\n    public compress() {\r\n        let files = this.files;\r\n        let file;\r\n        /** @type {!(Array.<number>|Uint8Array)} */\r\n        let output;\r\n        /** @type {number} */\r\n        let op1;\r\n        /** @type {number} */\r\n        let op2;\r\n        /** @type {number} */\r\n        let op3;\r\n        /** @type {number} */\r\n        let localFileSize = 0;\r\n        /** @type {number} */\r\n        let centralDirectorySize = 0;\r\n        /** @type {number} */\r\n        let endOfCentralDirectorySize;\r\n        /** @type {number} */\r\n        let offset;\r\n        /** @type {number} */\r\n        let needVersion;\r\n        /** @type {number} */\r\n        let flags;\r\n        /** @type {Zlib.Zip.CompressionMethod} */\r\n        let compressionMethod;\r\n        /** @type {Date} */\r\n        let date;\r\n        /** @type {number} */\r\n        let crc32;\r\n        /** @type {number} */\r\n        let size;\r\n        /** @type {number} */\r\n        let plainSize;\r\n        /** @type {number} */\r\n        let filenameLength;\r\n        /** @type {number} */\r\n        let extraFieldLength;\r\n        /** @type {number} */\r\n        let commentLength;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let filename;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let extraField;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let comment;\r\n        /** @type {(Array.<number>|Uint8Array)} */\r\n        let buffer;\r\n        /** @type {*} */\r\n        let tmp;\r\n        /** @type {Array.<number>|Uint32Array|Object} */\r\n        let key;\r\n        /** @type {number} */\r\n        let i;\r\n        /** @type {number} */\r\n        let il;\r\n        /** @type {number} */\r\n        let j;\r\n        /** @type {number} */\r\n        let jl;\r\n\r\n        for (i = 0, il = files.length; i < il; ++i) {\r\n          file = files[i];\r\n          filenameLength =\r\n            (file.option['filename']) ? file.option['filename'].length : 0;\r\n          extraFieldLength =\r\n            (file.option['extraField']) ? file.option['extraField'].length : 0;\r\n          commentLength =\r\n            (file.option['comment']) ? file.option['comment'].length : 0;\r\n      \r\n          // 圧縮されていなかったら圧縮\r\n          if (!file.compressed) {\r\n            // 圧縮前に CRC32 の計算をしておく\r\n            file.crc32 = ZlibT.CRC32.calc(file.buffer);\r\n      \r\n            switch (file.option['compressionMethod']) {\r\n              case Zip.CompressionMethod.STORE:\r\n                break;\r\n              case Zip.CompressionMethod.DEFLATE:\r\n                file.buffer = this.deflateWithOption(file.buffer, file.option);\r\n                file.compressed = true;\r\n                break;\r\n              default:\r\n                throw new Error('unknown compression method:' + file.option['compressionMethod']);\r\n            }\r\n          }\r\n      \r\n          // encryption\r\n          if (file.option['password'] !== void 0|| this.password !== void 0) {\r\n            // init encryption\r\n            key = Zip.createEncryptionKey(file.option['password'] || this.password);\r\n      \r\n            // add header\r\n            buffer = file.buffer;\r\n            if (USE_TYPEDARRAY) {\r\n              tmp = new Uint8Array(buffer.length + 12);\r\n              tmp.set(buffer, 12);\r\n              buffer = tmp;\r\n            } else {\r\n              buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n            }\r\n      \r\n            for (j = 0; j < 12; ++j) {\r\n              buffer[j] = this.encode(\r\n                key,\r\n                i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\r\n              );\r\n            }\r\n      \r\n            // data encryption\r\n            for (jl = buffer.length; j < jl; ++j) {\r\n              buffer[j] = this.encode(key, buffer[j]);\r\n            }\r\n            file.buffer = buffer;\r\n          }\r\n      \r\n          // 必要バッファサイズの計算\r\n          localFileSize +=\r\n            // local file header\r\n            30 + filenameLength +\r\n            // file data\r\n            file.buffer.length;\r\n      \r\n          centralDirectorySize +=\r\n            // file header\r\n            46 + filenameLength + commentLength;\r\n        }\r\n      \r\n        // end of central directory\r\n        endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\r\n        output = new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n          localFileSize + centralDirectorySize + endOfCentralDirectorySize\r\n        );\r\n        op1 = 0;\r\n        op2 = localFileSize;\r\n        op3 = op2 + centralDirectorySize;\r\n      \r\n        // ファイルの圧縮\r\n        for (i = 0, il = files.length; i < il; ++i) {\r\n          file = files[i];\r\n          filenameLength =\r\n            file.option['filename'] ? file.option['filename'].length :  0;\r\n          extraFieldLength = 0; // TODO\r\n          commentLength =\r\n            file.option['comment'] ? file.option['comment'].length : 0;\r\n      \r\n          //-------------------------------------------------------------------------\r\n          // local file header & file header\r\n          //-------------------------------------------------------------------------\r\n      \r\n          offset = op1;\r\n      \r\n          // signature\r\n          // local file header\r\n          output[op1++] = Zip.LocalFileHeaderSignature[0];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[1];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[2];\r\n          output[op1++] = Zip.LocalFileHeaderSignature[3];\r\n          // file header\r\n          output[op2++] = Zip.FileHeaderSignature[0];\r\n          output[op2++] = Zip.FileHeaderSignature[1];\r\n          output[op2++] = Zip.FileHeaderSignature[2];\r\n          output[op2++] = Zip.FileHeaderSignature[3];\r\n      \r\n          // compressor info\r\n          needVersion = 20;\r\n          output[op2++] = needVersion & 0xff;\r\n          output[op2++] =\r\n            /** @type {Zlib.Zip.OperatingSystem} */\r\n            (file.option['os']) ||\r\n            Zip.OperatingSystem.MSDOS;\r\n      \r\n          // need version\r\n          output[op1++] = output[op2++] =  needVersion       & 0xff;\r\n          output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\r\n      \r\n          // general purpose bit flag\r\n          flags = 0;\r\n          if (file.option['password'] || this.password) {\r\n            flags |= Zip.Flags.ENCRYPT;\r\n          }\r\n          output[op1++] = output[op2++] =  flags       & 0xff;\r\n          output[op1++] = output[op2++] = (flags >> 8) & 0xff;\r\n      \r\n          // compression method\r\n          compressionMethod =\r\n            /** @type {Zlib.Zip.CompressionMethod} */\r\n            (file.option['compressionMethod']);\r\n          output[op1++] = output[op2++] =  compressionMethod       & 0xff;\r\n          output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\r\n      \r\n          // date\r\n          date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\r\n          output[op1++] = output[op2++] =\r\n            ((date.getMinutes() & 0x7) << 5) |\r\n            (date.getSeconds() / 2 | 0);\r\n          output[op1++] = output[op2++] =\r\n            (date.getHours()   << 3) |\r\n            (date.getMinutes() >> 3);\r\n          //\r\n          output[op1++] = output[op2++] =\r\n            ((date.getMonth() + 1 & 0x7) << 5) |\r\n            (date.getDate());\r\n          output[op1++] = output[op2++] =\r\n            ((date.getFullYear() - 1980 & 0x7f) << 1) |\r\n            (date.getMonth() + 1 >> 3);\r\n      \r\n          // CRC-32\r\n          crc32 = file.crc32;\r\n          output[op1++] = output[op2++] =  crc32        & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\r\n      \r\n          // compressed size\r\n          size = file.buffer.length;\r\n          output[op1++] = output[op2++] =  size        & 0xff;\r\n          output[op1++] = output[op2++] = (size >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (size >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (size >> 24) & 0xff;\r\n      \r\n          // uncompressed size\r\n          plainSize = file.size;\r\n          output[op1++] = output[op2++] =  plainSize        & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\r\n          output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\r\n      \r\n          // filename length\r\n          output[op1++] = output[op2++] =  filenameLength       & 0xff;\r\n          output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\r\n      \r\n          // extra field length\r\n          output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\r\n          output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\r\n      \r\n          // file comment length\r\n          output[op2++] =  commentLength       & 0xff;\r\n          output[op2++] = (commentLength >> 8) & 0xff;\r\n      \r\n          // disk number start\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // internal file attributes\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // external file attributes\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n          output[op2++] = 0;\r\n      \r\n          // relative offset of local header\r\n          output[op2++] =  offset        & 0xff;\r\n          output[op2++] = (offset >>  8) & 0xff;\r\n          output[op2++] = (offset >> 16) & 0xff;\r\n          output[op2++] = (offset >> 24) & 0xff;\r\n      \r\n          // filename\r\n          filename = file.option['filename'];\r\n          if (filename) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(filename, op1);\r\n              output.set(filename, op2);\r\n              op1 += filenameLength;\r\n              op2 += filenameLength;\r\n            } else {\r\n              for (j = 0; j < filenameLength; ++j) {\r\n                output[op1++] = output[op2++] = filename[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          // extra field\r\n          extraField = file.option['extraField'];\r\n          if (extraField) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(extraField, op1);\r\n              output.set(extraField, op2);\r\n              op1 += extraFieldLength;\r\n              op2 += extraFieldLength;\r\n            } else {\r\n              for (j = 0; j < commentLength; ++j) {\r\n                output[op1++] = output[op2++] = extraField[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          // comment\r\n          comment = file.option['comment'];\r\n          if (comment) {\r\n            if (USE_TYPEDARRAY) {\r\n              output.set(comment, op2);\r\n              op2 += commentLength;\r\n            } else {\r\n              for (j = 0; j < commentLength; ++j) {\r\n                output[op2++] = comment[j];\r\n              }\r\n            }\r\n          }\r\n      \r\n          //-------------------------------------------------------------------------\r\n          // file data\r\n          //-------------------------------------------------------------------------\r\n      \r\n          if (USE_TYPEDARRAY) {\r\n            output.set(file.buffer, op1);\r\n            op1 += file.buffer.length;\r\n          } else {\r\n            for (j = 0, jl = file.buffer.length; j < jl; ++j) {\r\n              output[op1++] = file.buffer[j];\r\n            }\r\n          }\r\n        }\r\n      \r\n        //-------------------------------------------------------------------------\r\n        // end of central directory\r\n        //-------------------------------------------------------------------------\r\n      \r\n        // signature\r\n        output[op3++] = Zip.CentralDirectorySignature[0];\r\n        output[op3++] = Zip.CentralDirectorySignature[1];\r\n        output[op3++] = Zip.CentralDirectorySignature[2];\r\n        output[op3++] = Zip.CentralDirectorySignature[3];\r\n      \r\n        // number of this disk\r\n        output[op3++] = 0;\r\n        output[op3++] = 0;\r\n      \r\n        // number of the disk with the start of the central directory\r\n        output[op3++] = 0;\r\n        output[op3++] = 0;\r\n      \r\n        // total number of entries in the central directory on this disk\r\n        output[op3++] =  il       & 0xff;\r\n        output[op3++] = (il >> 8) & 0xff;\r\n      \r\n        // total number of entries in the central directory\r\n        output[op3++] =  il       & 0xff;\r\n        output[op3++] = (il >> 8) & 0xff;\r\n      \r\n        // size of the central directory\r\n        output[op3++] =  centralDirectorySize        & 0xff;\r\n        output[op3++] = (centralDirectorySize >>  8) & 0xff;\r\n        output[op3++] = (centralDirectorySize >> 16) & 0xff;\r\n        output[op3++] = (centralDirectorySize >> 24) & 0xff;\r\n      \r\n        // offset of start of central directory with respect to the starting disk number\r\n        output[op3++] =  localFileSize        & 0xff;\r\n        output[op3++] = (localFileSize >>  8) & 0xff;\r\n        output[op3++] = (localFileSize >> 16) & 0xff;\r\n        output[op3++] = (localFileSize >> 24) & 0xff;\r\n      \r\n        // .ZIP file comment length\r\n        commentLength = this.comment ? this.comment.length : 0;\r\n        output[op3++] =  commentLength       & 0xff;\r\n        output[op3++] = (commentLength >> 8) & 0xff;\r\n      \r\n        // .ZIP file comment\r\n        if (this.comment) {\r\n          if (USE_TYPEDARRAY) {\r\n            output.set(this.comment, op3);\r\n            op3 += commentLength;\r\n          } else {\r\n            for (j = 0, jl = commentLength; j < jl; ++j) {\r\n              output[op3++] = this.comment[j];\r\n            }\r\n          }\r\n        } \r\n        return output;\r\n    }\r\n\r\n    public deflateWithOption(input: Array<number> | Uint8Array, opt_params: Object) {\r\n        /** @type {Zlib.RawDeflate} */\r\n        const deflator = new ZlibT.RawDeflate(input, opt_params['deflateOption']);\r\n      \r\n        return deflator.compress();\r\n    }\r\n\r\n    public static getByte(key: Array<number> | Uint32Array) {\r\n        const tmp = ((key[2] & 0xffff) | 2);\r\n        return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\r\n    };\r\n\r\n    public encode(key: Array<number> | Uint32Array, n: number) {\r\n        /** @type {number} */\r\n        const tmp = Zip.getByte(key);\r\n      \r\n        Zip.updateKeys(key, n);\r\n      \r\n        return tmp ^ n;\r\n    };\r\n\r\n    public static updateKeys = function(key: Array<number> | Uint32Array, n: number) {\r\n            key[0] = ZlibT.CRC32.single(key[0], n);\r\n            key[1] =\r\n            (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\r\n            key[2] = ZlibT.CRC32.single(key[2], key[1] >>> 24);\r\n    }\r\n    \r\n    public static createEncryptionKey(password: Array<number>|Uint8Array) {\r\n        /** @type {!(Array.<number>|Uint32Array)} */\r\n        const keyOrigin = [305419896, 591751049, 878082192];\r\n        /** @type {number} */\r\n        let i = 0 ;\r\n        /** @type {number} */\r\n        let il = password.length;\r\n        let key = USE_TYPEDARRAY ? new Uint32Array(keyOrigin) : keyOrigin;\r\n    \r\n        for (; i < il; ++i) {\r\n            Zip.updateKeys(key, password[i] & 0xff);\r\n        }\r\n        return key;\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nexport let ZLIB_CRC32_COMPACT = false;\r\nexport class CRC32 {\r\n    constructor() {\r\n    }\r\n    public static calc(data: Array<number> | Uint8Array, pos?: number, length?: number) {\r\n        return this.update(data, 0, pos, length);\r\n    }\r\n    public static update = function(data: Array<number> | Uint8Array, crc: number, pos: number, length: number) {\r\n        let table = CRC32.Table;\r\n        let i = (typeof pos === 'number') ? pos : (pos = 0);\r\n        let il = (typeof length === 'number') ? length : data.length;\r\n        crc ^= 0xffffffff;\r\n        // loop unrolling for performance\r\n        for (i = il & 7; i--; ++pos) {\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];\r\n        }\r\n        for (i = il >> 3; i--; pos += 8) {\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];\r\n          crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];\r\n        }\r\n        return (crc ^ 0xffffffff) >>> 0;\r\n    }\r\n    public static single(num: number, crc: number) {\r\n        return (CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;\r\n    };\r\n    public static Table_ = [\r\n        0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\r\n        0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\r\n        0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\r\n        0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\r\n        0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\r\n        0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\r\n        0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\r\n        0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\r\n        0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\r\n        0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\r\n        0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\r\n        0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\r\n        0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\r\n        0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\r\n        0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\r\n        0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\r\n        0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\r\n        0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\r\n        0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\r\n        0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\r\n        0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\r\n        0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\r\n        0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\r\n        0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\r\n        0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\r\n        0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\r\n        0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\r\n        0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\r\n        0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\r\n        0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\r\n        0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\r\n        0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\r\n        0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\r\n        0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\r\n        0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\r\n        0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\r\n        0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\r\n        0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\r\n        0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\r\n        0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\r\n        0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\r\n        0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\r\n        0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\r\n      ];\r\n      public static get Table() {\r\n        if (ZLIB_CRC32_COMPACT) {\r\n            let table = new (USE_TYPEDARRAY ? Uint32Array : Array)(256);\r\n            let c: number;\r\n            let i: number;\r\n            let j: number;\r\n          \r\n            for (i = 0; i < 256; ++i) {\r\n              c = i;\r\n              for (j = 0; j < 8; ++j) {\r\n                c = (c & 1) ? (0xedB88320 ^ (c >>> 1)) : (c >>> 1);\r\n              }\r\n              table[i] = c >>> 0;\r\n            }\r\n          \r\n            return table\r\n        } else if (USE_TYPEDARRAY) {\r\n            return new Uint32Array(CRC32.Table_);\r\n        } else {\r\n            return CRC32.Table_;\r\n        }\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\nexport class Heap {\r\n    \r\n    public buffer: Uint16Array | Array<number>;\r\n    public length: number;\r\n    \r\n    constructor(length: number) {\r\n        this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\r\n        this.length = 0;\r\n    }\r\n\r\n    public getParent(index: number) {\r\n        return ((index - 2) / 4 | 0) * 2;\r\n    };\r\n\r\n    public getChild = function(index: number) {\r\n        return 2 * index + 2;\r\n    };\r\n\r\n    public push(index: number, value: number) {\r\n        let current, parent,\r\n            heap = this.buffer,\r\n            swap;\r\n      \r\n        current = this.length;\r\n        heap[this.length++] = value;\r\n        heap[this.length++] = index;\r\n      \r\n        while (current > 0) {\r\n          parent = this.getParent(current);\r\n      \r\n          if (heap[current] > heap[parent]) {\r\n            swap = heap[current];\r\n            heap[current] = heap[parent];\r\n            heap[parent] = swap;\r\n      \r\n            swap = heap[current + 1];\r\n            heap[current + 1] = heap[parent + 1];\r\n            heap[parent + 1] = swap;\r\n      \r\n            current = parent;\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        return this.length;\r\n    }\r\n\r\n    public pop() {\r\n        let index, value,\r\n            heap = this.buffer, swap,\r\n            current, parent;\r\n      \r\n        value = heap[0];\r\n        index = heap[1];\r\n      \r\n        this.length -= 2;\r\n        heap[0] = heap[this.length];\r\n        heap[1] = heap[this.length + 1];\r\n      \r\n        parent = 0;\r\n        while (true) {\r\n          current = this.getChild(parent);\r\n      \r\n          if (current >= this.length) {\r\n            break;\r\n          }\r\n      \r\n          if (current + 2 < this.length && heap[current + 2] > heap[current]) {\r\n            current += 2;\r\n          }\r\n      \r\n          if (heap[current] > heap[parent]) {\r\n            swap = heap[parent];\r\n            heap[parent] = heap[current];\r\n            heap[current] = swap;\r\n      \r\n            swap = heap[parent + 1];\r\n            heap[parent + 1] = heap[current + 1];\r\n            heap[current + 1] = swap;\r\n          } else {\r\n            break;\r\n          }\r\n      \r\n          parent = current;\r\n        }\r\n        return {index: index, value: value, length: this.length};\r\n    }\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\n\r\n/**\r\n * build huffman table from length list.\r\n * @param {!(Array.<number>|Uint8Array)} lengths length list.\r\n * @return {!Array} huffman table.\r\n */\r\nexport class Huffman {\r\n    constructor() {\r\n    \r\n    }\r\n    public static buildHuffmanTable(lengths: Array<number>|Uint8Array) {\r\n        /** @type {number} length list size. */\r\n        let listSize = lengths.length;\r\n        /** @type {number} max code length for table size. */\r\n        let maxCodeLength = 0;\r\n        /** @type {number} min code length for table size. */\r\n        let minCodeLength = Number.POSITIVE_INFINITY;\r\n        /** @type {number} table size. */\r\n        let size;\r\n        /** @type {!(Array|Uint8Array)} huffman code table. */\r\n        let table;\r\n        /** @type {number} bit length. */\r\n        let bitLength;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /**\r\n         * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.\r\n         * @type {number} skip length for table filling.\r\n         */\r\n        let skip;\r\n        /** @type {number} reversed code. */\r\n        let reversed;\r\n        /** @type {number} reverse temp. */\r\n        let rtemp;\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limit. */\r\n        let il;\r\n        /** @type {number} loop counter. */\r\n        let j;\r\n        /** @type {number} table value. */\r\n        let value;\r\n\r\n        // Math.max は遅いので最長の値は for-loop で取得する\r\n        for (i = 0, il = listSize; i < il; ++i) {\r\n            if (lengths[i] > maxCodeLength) {\r\n            maxCodeLength = lengths[i];\r\n            }\r\n            if (lengths[i] < minCodeLength) {\r\n            minCodeLength = lengths[i];\r\n            }\r\n        }\r\n\r\n        size = 1 << maxCodeLength;\r\n        table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);\r\n\r\n        // ビット長の短い順からハフマン符号を割り当てる\r\n        for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\r\n            for (i = 0; i < listSize; ++i) {\r\n            if (lengths[i] === bitLength) {\r\n                // ビットオーダーが逆になるためビット長分並びを反転する\r\n                for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\r\n                reversed = (reversed << 1) | (rtemp & 1);\r\n                rtemp >>= 1;\r\n                }\r\n\r\n                // 最大ビット長をもとにテーブルを作るため、\r\n                // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる\r\n                // そのどちらでも良い場所は同じ値で埋めることで\r\n                // 本来のビット長以上のビット数取得しても問題が起こらないようにする\r\n                value = (bitLength << 16) | i;\r\n                for (j = reversed; j < size; j += skip) {\r\n                table[j] = value;\r\n                }\r\n\r\n                ++code;\r\n            }\r\n            }\r\n\r\n            // 次のビット長へ\r\n            ++bitLength;\r\n            code <<= 1;\r\n            skip <<= 1;\r\n        }\r\n\r\n        return [table, maxCodeLength, minCodeLength];\r\n    }\r\n}\r\n","\r\nimport { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { ZlibT } from './zlibt';\r\n\r\nenum rBufferType {\r\n    BLOCK= 0,\r\n    ADAPTIVE= 1\r\n};\r\nexport class RawInflate{\r\n    public static ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; \r\n    public static buildHuffmanTable = ZlibT.Huffman.buildHuffmanTable;\r\n    public static BufferType = rBufferType;\r\n\r\n    public static MaxBackwardLength = 32768;\r\n    public static MaxCopyLength = 258;\r\n\r\n    public currentLitlenTable: Array<number> | Uint16Array;\r\n    public static Order = (() =>{\r\n        const table = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static LengthCodeTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })([\r\n        0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n        0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n        0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n        0x00e3, 0x0102, 0x0102, 0x0102\r\n    ]);\r\n\r\n    public static LengthExtraTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })([\r\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n        5, 5, 0, 0, 0\r\n    ]);\r\n\r\n    public static DistCodeTable = ((table) => {\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n      })([\r\n        0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n        0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n        0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n        0x3001, 0x4001, 0x6001\r\n      ]);\r\n\r\n    public static DistExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n            11, 12, 12, 13, 13\r\n          ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })()\r\n\r\n    public static FixedLiteralLengthTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] =\r\n            (i <= 143) ? 8 :\r\n            (i <= 255) ? 9 :\r\n            (i <= 279) ? 7 :\r\n            8;\r\n        }\r\n      \r\n        return RawInflate.buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public static FixedDistanceTable = ((table) => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] = 5;\r\n        }\r\n      \r\n        return RawInflate.buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public buffer: Array<number>|Uint8Array;\r\n    public blocks: Array<(Array<number>|Uint8Array)>;\r\n    public bufferSize: number;\r\n    public totalpos: number;\r\n    public ip;\r\n    public bitsbuf;\r\n    public bitsbuflen;\r\n    public input: Array<number>|Uint8Array;\r\n    public output: Array<number>|Uint8Array;\r\n    /** @type {!number} output buffer pointer. */\r\n    public op: number;\r\n    /** @type {boolean} is final block flag. */\r\n    public bfinal = false;\r\n    /** @type {Zlib.RawInflate.BufferType} buffer management. */\r\n    public bufferType = RawInflate.BufferType.ADAPTIVE;\r\n    /** @type {boolean} resize flag for memory size optimization. */\r\n    public resize = false;\r\n    constructor(input: Uint8Array | Array<number>, opt_params: any) {\r\n        /** @type {!Array.<(Array.<number>|Uint8Array)>} */\r\n        this.blocks = [];\r\n        /** @type {number} block size. */\r\n        this.bufferSize = RawInflate.ZLIB_RAW_INFLATE_BUFFER_SIZE;\r\n        /** @type {!number} total output buffer pointer. */\r\n        this.totalpos = 0;\r\n        /** @type {!number} input buffer pointer. */\r\n        this.ip = 0;\r\n        /** @type {!number} bit stream reader buffer. */\r\n        this.bitsbuf = 0;\r\n        /** @type {!number} bit stream reader buffer size. */\r\n        this.bitsbuflen = 0;\r\n        /** @type {!(Array.<number>|Uint8Array)} input buffer. */\r\n        this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n        /** @type {boolean} is final block flag. */\r\n        this.bfinal = false;\r\n        /** @type {Zlib.RawInflate.BufferType} buffer management. */\r\n        this.bufferType = RawInflate.BufferType.ADAPTIVE;\r\n        /** @type {boolean} resize flag for memory size optimization. */\r\n        this.resize = false;\r\n    \r\n    // option parameters\r\n        if (opt_params || !(opt_params = {})) {\r\n            if (opt_params['index']) {\r\n            this.ip = opt_params['index'];\r\n            }\r\n            if (opt_params['bufferSize']) {\r\n            this.bufferSize = opt_params['bufferSize'];\r\n            }\r\n            if (opt_params['bufferType']) {\r\n            this.bufferType = opt_params['bufferType'];\r\n            }\r\n            if (opt_params['resize']) {\r\n            this.resize = opt_params['resize'];\r\n            }\r\n        }\r\n    \r\n    // initialize\r\n        switch (this.bufferType) {\r\n            case RawInflate.BufferType.BLOCK:\r\n            this.op = RawInflate.MaxBackwardLength;\r\n            this.output =\r\n                new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n                RawInflate.MaxBackwardLength +\r\n                this.bufferSize +\r\n                RawInflate.MaxCopyLength\r\n                );\r\n            break;\r\n            case RawInflate.BufferType.ADAPTIVE:\r\n            this.op = 0;\r\n            this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n            break;\r\n            default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public decompress() {\r\n        while (!this.bfinal) {\r\n          this.parseBlock();\r\n        }\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.BLOCK:\r\n            return this.concatBufferBlock();\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            return this.concatBufferDynamic();\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n    public parseBlock() {\r\n        /** @type {number} header */\r\n        let hdr = this.readBits(3);\r\n      \r\n        // BFINAL\r\n        if (hdr & 0x1) {\r\n          this.bfinal = true;\r\n        }\r\n      \r\n        // BTYPE\r\n        hdr >>>= 1;\r\n        switch (hdr) {\r\n          // uncompressed\r\n          case 0:\r\n            this.parseUncompressedBlock();\r\n            break;\r\n          // fixed huffman\r\n          case 1:\r\n            this.parseFixedHuffmanBlock();\r\n            break;\r\n          // dynamic huffman\r\n          case 2:\r\n            this.parseDynamicHuffmanBlock();\r\n            break;\r\n          // reserved or other\r\n          default:\r\n            throw new Error('unknown BTYPE: ' + hdr);\r\n        }\r\n    }\r\n    public readBits(length) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {number} input and output byte. */\r\n        let octet;\r\n      \r\n        // input byte\r\n        if (ip + ((length - bitsbuflen + 7) >> 3) >= inputLength) {\r\n          throw new Error('input buffer is broken');\r\n        }\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < length) {\r\n          bitsbuf |= input[ip++] << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // output byte\r\n        octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n        bitsbuf >>>= length;\r\n        bitsbuflen -= length;\r\n      \r\n        this.bitsbuf = bitsbuf;\r\n        this.bitsbuflen = bitsbuflen;\r\n        this.ip = ip;\r\n      \r\n        return octet;\r\n    }\r\n\r\n    public readCodeByTable(table) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {!(Array.<number>|Uint8Array)} huffman code table */\r\n        let codeTable = table[0];\r\n        /** @type {number} */\r\n        let maxCodeLength = table[1];\r\n        /** @type {number} code length & code (16bit, 16bit) */\r\n        let codeWithLength;\r\n        /** @type {number} code bits length */\r\n        let codeLength;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < maxCodeLength) {\r\n          if (ip >= inputLength) {\r\n            break;\r\n          }\r\n          bitsbuf |= input[ip++] << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // read max length\r\n        codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n        codeLength = codeWithLength >>> 16;\r\n      \r\n        if (codeLength > bitsbuflen) {\r\n          throw new Error('invalid code length: ' + codeLength);\r\n        }\r\n      \r\n        this.bitsbuf = bitsbuf >> codeLength;\r\n        this.bitsbuflen = bitsbuflen - codeLength;\r\n        this.ip = ip;\r\n      \r\n        return codeWithLength & 0xffff;\r\n      }\r\n\r\n      public parseUncompressedBlock() {\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        /** @type {number} */\r\n        let inputLength = input.length;\r\n        /** @type {number} block length */\r\n        let len;\r\n        /** @type {number} number for check block length */\r\n        let nlen;\r\n        /** @type {number} output buffer length */\r\n        let olength = output.length;\r\n        /** @type {number} copy counter */\r\n        let preCopy;\r\n      \r\n        // skip buffered header bits\r\n        this.bitsbuf = 0;\r\n        this.bitsbuflen = 0;\r\n      \r\n        // len\r\n        if (ip + 1 >= inputLength) {\r\n          throw new Error('invalid uncompressed block header: LEN');\r\n        }\r\n        len = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // nlen\r\n        if (ip + 1 >= inputLength) {\r\n          throw new Error('invalid uncompressed block header: NLEN');\r\n        }\r\n        nlen = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // check len & nlen\r\n        if (len === ~nlen) {\r\n          throw new Error('invalid uncompressed block header: length verify');\r\n        }\r\n      \r\n        // check size\r\n        if (ip + len > input.length) { throw new Error('input buffer is broken'); }\r\n      \r\n        // expand buffer\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.BLOCK:\r\n            // pre copy\r\n            while (op + len > output.length) {\r\n              preCopy = olength - op;\r\n              len -= preCopy;\r\n              if (USE_TYPEDARRAY) {\r\n                (<Uint8Array>output).set((<Uint8Array>input).subarray(ip, ip + preCopy), op);\r\n                op += preCopy;\r\n                ip += preCopy;\r\n              } else {\r\n                while (preCopy--) {\r\n                  output[op++] = input[ip++];\r\n                }\r\n              }\r\n              this.op = op;\r\n              output = this.expandBufferBlock();\r\n              op = this.op;\r\n            }\r\n            break;\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            while (op + len > output.length) {\r\n              output = this.expandBufferAdaptive({fixRatio: 2});\r\n            }\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n      \r\n        // copy\r\n        if (USE_TYPEDARRAY) {\r\n            (<Uint8Array>output).set((<Uint8Array>input).subarray(ip, ip + len), op);\r\n          op += len;\r\n          ip += len;\r\n        } else {\r\n          while (len--) {\r\n            output[op++] = input[ip++];\r\n          }\r\n        }\r\n      \r\n        this.ip = ip;\r\n        this.op = op;\r\n        this.output = output;\r\n    }\r\n\r\n    public parseFixedHuffmanBlock() {\r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            this.decodeHuffmanAdaptive(\r\n              RawInflate.FixedLiteralLengthTable,\r\n              RawInflate.FixedDistanceTable\r\n            );\r\n            break;\r\n          case RawInflate.BufferType.BLOCK:\r\n            this.decodeHuffmanBlock(\r\n              RawInflate.FixedLiteralLengthTable,\r\n              RawInflate.FixedDistanceTable\r\n            );\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public parseDynamicHuffmanBlock() {\r\n        /** @type {number} number of literal and length codes. */\r\n        let hlit = this.readBits(5) + 257;\r\n        /** @type {number} number of distance codes. */\r\n        let hdist = this.readBits(5) + 1;\r\n        /** @type {number} number of code lengths. */\r\n        let hclen = this.readBits(4) + 4;\r\n        /** @type {!(Uint8Array|Array.<number>)} code lengths. */\r\n        let codeLengths =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflate.Order.length);\r\n        /** @type {!Array} code lengths table. */\r\n        let codeLengthsTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\r\n        let litlenTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} distance code table. */\r\n        let distTable;\r\n        /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n        let lengthTable;\r\n        /** @type {number} */\r\n        let code;\r\n        /** @type {number} */\r\n        let prev;\r\n        /** @type {number} */\r\n        let repeat;\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limit. */\r\n        let il;\r\n      \r\n        // decode code lengths\r\n        for (i = 0; i < hclen; ++i) {\r\n          codeLengths[RawInflate.Order[i]] = this.readBits(3);\r\n        }\r\n        if (!USE_TYPEDARRAY) {\r\n          for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {\r\n            codeLengths[RawInflate.Order[i]] = 0;\r\n          }\r\n        }\r\n      \r\n        // decode length table\r\n        codeLengthsTable = RawInflate.buildHuffmanTable(codeLengths);\r\n        lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n        for (i = 0, il = hlit + hdist; i < il;) {\r\n          code = this.readCodeByTable(codeLengthsTable);\r\n          switch (code) {\r\n            case 16:\r\n              repeat = 3 + this.readBits(2);\r\n              while (repeat--) { lengthTable[i++] = prev; }\r\n              break;\r\n            case 17:\r\n              repeat = 3 + this.readBits(3);\r\n              while (repeat--) { lengthTable[i++] = 0; }\r\n              prev = 0;\r\n              break;\r\n            case 18:\r\n              repeat = 11 + this.readBits(7);\r\n              while (repeat--) { lengthTable[i++] = 0; }\r\n              prev = 0;\r\n              break;\r\n            default:\r\n              lengthTable[i++] = code;\r\n              prev = code;\r\n              break;\r\n          }\r\n        }\r\n      \r\n        litlenTable = USE_TYPEDARRAY\r\n          ? RawInflate.buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n          : RawInflate.buildHuffmanTable(lengthTable.slice(0, hlit));\r\n        distTable = USE_TYPEDARRAY\r\n          ? RawInflate.buildHuffmanTable(lengthTable.subarray(hlit))\r\n          : RawInflate.buildHuffmanTable(lengthTable.slice(hlit));\r\n      \r\n        switch (this.bufferType) {\r\n          case RawInflate.BufferType.ADAPTIVE:\r\n            this.decodeHuffmanAdaptive(litlenTable, distTable);\r\n            break;\r\n          case RawInflate.BufferType.BLOCK:\r\n            this.decodeHuffmanBlock(litlenTable, distTable);\r\n            break;\r\n          default:\r\n            throw new Error('invalid inflate mode');\r\n        }\r\n    }\r\n\r\n    public decodeHuffmanBlock(litlen: Array<number>|Uint16Array, dist: Array<number>|Uint8Array) {\r\n        let output = this.output;\r\n        let op = this.op;\r\n        \r\n        this.currentLitlenTable = litlen;\r\n        \r\n        /** @type {number} output position limit. */\r\n        let olength = output.length - RawInflate.MaxCopyLength;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n        \r\n        let lengthCodeTable = RawInflate.LengthCodeTable;\r\n        let lengthExtraTable = RawInflate.LengthExtraTable;\r\n        let distCodeTable = RawInflate.DistCodeTable;\r\n        let distExtraTable = RawInflate.DistExtraTable;\r\n        \r\n        code = this.readCodeByTable(litlen);\r\n        while ( code !== 256) {\r\n            // literal\r\n            if (code < 256) {\r\n            if (op >= olength) {\r\n                this.op = op;\r\n                output = this.expandBufferBlock();\r\n                op = this.op;\r\n            }\r\n            output[op++] = code;\r\n        \r\n            continue;\r\n            }\r\n        \r\n            // length code\r\n            ti = code - 257;\r\n            codeLength = lengthCodeTable[ti];\r\n            if (lengthExtraTable[ti] > 0) {\r\n            codeLength += this.readBits(lengthExtraTable[ti]);\r\n            }\r\n        \r\n            // dist code\r\n            code = this.readCodeByTable(dist);\r\n            codeDist = distCodeTable[code];\r\n            if (distExtraTable[code] > 0) {\r\n            codeDist += this.readBits(distExtraTable[code]);\r\n            }\r\n        \r\n            // lz77 decode\r\n            if (op >= olength) {\r\n            this.op = op;\r\n            output = this.expandBufferBlock();\r\n            op = this.op;\r\n            }\r\n            while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n            }\r\n            code = this.readCodeByTable(litlen);\r\n        }\r\n        \r\n        while (this.bitsbuflen >= 8) {\r\n            this.bitsbuflen -= 8;\r\n            this.ip--;\r\n        }\r\n        this.op = op;\r\n    }\r\n    public decodeHuffmanAdaptive(litlen: Array<number>|Uint16Array, dist: Array<number>|Uint8Array) {\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        this.currentLitlenTable = litlen;\r\n      \r\n        /** @type {number} output position limit. */\r\n        let olength = output.length;\r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n      \r\n        let lengthCodeTable = RawInflate.LengthCodeTable;\r\n        let lengthExtraTable = RawInflate.LengthExtraTable;\r\n        let distCodeTable = RawInflate.DistCodeTable;\r\n        let distExtraTable = RawInflate.DistExtraTable;\r\n    \r\n        code = this.readCodeByTable(litlen);\r\n        while (code !== 256) {\r\n          // literal\r\n          if (code < 256) {\r\n            if (op >= olength) {\r\n              output = this.expandBufferAdaptive();\r\n              olength = output.length;\r\n            }\r\n            output[op++] = code;\r\n      \r\n            continue;\r\n          }\r\n      \r\n          // length code\r\n          ti = code - 257;\r\n          codeLength = lengthCodeTable[ti];\r\n          if (lengthExtraTable[ti] > 0) {\r\n            codeLength += this.readBits(lengthExtraTable[ti]);\r\n          }\r\n      \r\n          // dist code\r\n          code = this.readCodeByTable(dist);\r\n          codeDist = distCodeTable[code];\r\n          if (distExtraTable[code] > 0) {\r\n            codeDist += this.readBits(distExtraTable[code]);\r\n          }\r\n      \r\n          // lz77 decode\r\n          if (op + codeLength > olength) {\r\n            output = this.expandBufferAdaptive();\r\n            olength = output.length;\r\n          }\r\n          while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n          }\r\n          code = this.readCodeByTable(litlen);\r\n        }\r\n      \r\n        while (this.bitsbuflen >= 8) {\r\n          this.bitsbuflen -= 8;\r\n          this.ip--;\r\n        }\r\n        this.op = op;\r\n    }\r\n    public expandBufferBlock(opt_param?: any) {\r\n        /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n        let buffer =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n              this.op - RawInflate.MaxBackwardLength\r\n          );\r\n        /** @type {number} backward base point */\r\n        let backward = this.op - RawInflate.MaxBackwardLength;\r\n        /** @type {number} copy index. */\r\n        let i;\r\n        /** @type {number} copy limit */\r\n        let il;\r\n      \r\n        let output = this.output;\r\n      \r\n        // copy to output buffer\r\n        if (USE_TYPEDARRAY) {\r\n          (<Uint8Array>buffer).set((<Uint8Array>output).subarray(RawInflate.MaxBackwardLength, buffer.length));\r\n        } else {\r\n          for (i = 0, il = buffer.length; i < il; ++i) {\r\n            buffer[i] = output[i + RawInflate.MaxBackwardLength];\r\n          }\r\n        }\r\n      \r\n        this.blocks.push(buffer);\r\n        this.totalpos += buffer.length;\r\n      \r\n        // copy to backward buffer\r\n        if (USE_TYPEDARRAY) {\r\n          (<Uint8Array>output).set(\r\n            (<Uint8Array>output).subarray(backward, backward + RawInflate.MaxBackwardLength)\r\n          );\r\n        } else {\r\n          for (i = 0; i < RawInflate.MaxBackwardLength; ++i) {\r\n            output[i] = output[backward + i];\r\n          }\r\n        }\r\n      \r\n        this.op = RawInflate.MaxBackwardLength;\r\n      \r\n        return output;\r\n    }\r\n    public expandBufferAdaptive(opt_param?: any) {\r\n        /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n        let buffer;\r\n        /** @type {number} expantion ratio. */\r\n        let ratio = (this.input.length / this.ip + 1) | 0;\r\n        /** @type {number} maximum number of huffman code. */\r\n        let maxHuffCode;\r\n        /** @type {number} new output buffer size. */\r\n        let newSize;\r\n        /** @type {number} max inflate size. */\r\n        let maxInflateSize;\r\n      \r\n        let input = this.input;\r\n        let output = this.output;\r\n      \r\n        if (opt_param) {\r\n          if (typeof opt_param.fixRatio === 'number') {\r\n            ratio = opt_param.fixRatio;\r\n          }\r\n          if (typeof opt_param.addRatio === 'number') {\r\n            ratio += opt_param.addRatio;\r\n          }\r\n        }\r\n      \r\n        // calculate new buffer size\r\n        if (ratio < 2) {\r\n          maxHuffCode =\r\n            (input.length - this.ip) / this.currentLitlenTable[2];\r\n          maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n          newSize = maxInflateSize < output.length ?\r\n            output.length + maxInflateSize :\r\n            output.length << 1;\r\n        } else {\r\n          newSize = output.length * ratio;\r\n        }\r\n      \r\n        // buffer expantion\r\n        if (USE_TYPEDARRAY) {\r\n          buffer = new Uint8Array(newSize);\r\n          buffer.set(output);\r\n        } else {\r\n          buffer = output;\r\n        }\r\n      \r\n        this.output = buffer;\r\n      \r\n        return this.output;\r\n    }\r\n\r\n    public concatBufferBlock() {\r\n        /** @type {number} buffer pointer. */\r\n        let pos = 0;\r\n        /** @type {number} buffer pointer. */\r\n        let limit = this.totalpos + (this.op - RawInflate.MaxBackwardLength);\r\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n        let output = this.output;\r\n        /** @type {!Array} blocks array. */\r\n        let blocks = this.blocks;\r\n        /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n        let block;\r\n        /** @type {!(Array.<number>|Uint8Array)} output buffer. */\r\n        let buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n        /** @type {number} loop counter. */\r\n        let i;\r\n        /** @type {number} loop limiter. */\r\n        let il;\r\n        /** @type {number} loop counter. */\r\n        let j;\r\n        /** @type {number} loop limiter. */\r\n        let jl;\r\n      \r\n        // single buffer\r\n        if (blocks.length === 0) {\r\n          return USE_TYPEDARRAY ?\r\n            (<Uint8Array>this.output).subarray(RawInflate.MaxBackwardLength, this.op) :\r\n            this.output.slice(RawInflate.MaxBackwardLength, this.op);\r\n        }\r\n      \r\n        // copy to buffer\r\n        for (i = 0, il = blocks.length; i < il; ++i) {\r\n          block = blocks[i];\r\n          for (j = 0, jl = block.length; j < jl; ++j) {\r\n            buffer[pos++] = block[j];\r\n          }\r\n        }\r\n      \r\n        // current buffer\r\n        for (i = RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\r\n          buffer[pos++] = output[i];\r\n        }\r\n      \r\n        this.blocks = [];\r\n        this.buffer = buffer;\r\n      \r\n        return this.buffer;\r\n    }\r\n    public concatBufferDynamic() {\r\n        /** @type {Array.<number>|Uint8Array} output buffer. */\r\n        let buffer;\r\n        let op = this.op;\r\n      \r\n        if (USE_TYPEDARRAY) {\r\n          if (this.resize) {\r\n            buffer = new Uint8Array(op);\r\n            buffer.set((<Uint8Array>this.output).subarray(0, op));\r\n          } else {\r\n            buffer = (<Uint8Array>this.output).subarray(0, op);\r\n          }\r\n        } else {\r\n          if (this.output.length > op) {\r\n            this.output = this.output.slice(0,op-1);\r\n          }\r\n          buffer = this.output;\r\n        }\r\n      \r\n        this.buffer = buffer;\r\n      \r\n        return this.buffer;\r\n      };\r\n}\r\n","import { USE_TYPEDARRAY } from './define/typedarray/hybrid';\r\nimport { ZlibT } from './zlibt';\r\n\r\nconst ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 0x8000;\r\n\r\nenum rStatus {\r\n    INITIALIZED= 0,\r\n    BLOCK_HEADER_START= 1,\r\n    BLOCK_HEADER_END= 2,\r\n    BLOCK_BODY_START= 3,\r\n    BLOCK_BODY_END= 4,\r\n    DECODE_BLOCK_START= 5,\r\n    DECODE_BLOCK_END= 6\r\n};\r\n\r\nenum rBlockType {\r\n    UNCOMPRESSED= 0,\r\n    FIXED= 1,\r\n    DYNAMIC= 2,\r\n};\r\n\r\nconst buildHuffmanTable = ZlibT.Huffman.buildHuffmanTable;\r\n\r\nexport class RawInflateStream {\r\n\r\n    public static Status = rStatus;\r\n    public static BlockType= rBlockType;\r\n\r\n    public blocks : Array<(Array<number> | Uint8Array)>;\r\n    public bufferSize: number;\r\n    public totalpos: number;\r\n    public ip: number;\r\n    public bitsbuf: number;\r\n    public bitsbuflen: number;\r\n    public input: Array<number> | Uint8Array;\r\n    public output: Array<number> | Uint8Array;\r\n    public op: number;\r\n    public bfinal: boolean;\r\n    public blockLength: number;\r\n    public resize: boolean;\r\n    public litlenTable: Array<number>;\r\n    public distTable: Array<number>;\r\n    public sp: number;\r\n    public status=0;\r\n    public ip_;\r\n    public bitsbuflen_;\r\n    public bitsbuf_;\r\n    public currentBlockType;\r\n\r\n    public static MaxBackwardLength = 32768;\r\n\r\n    public static MaxCopyLength = 258;\r\n\r\n    public static Order = (()=>{\r\n        let table = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static LengthCodeTable = (() => {\r\n        const table = [\r\n            0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n            0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n            0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n            0x00e3, 0x0102, 0x0102, 0x0102\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n    \r\n    public static LengthExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n            5, 5, 0, 0, 0\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })();\r\n\r\n    public static DistCodeTable = (() => {\r\n        let table = [\r\n            0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n            0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n            0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n            0x3001, 0x4001, 0x6001\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n    })();\r\n\r\n    public static DistExtraTable = (() => {\r\n        const table = [\r\n            0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n            11, 12, 12, 13, 13\r\n        ]\r\n        return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n    })();\r\n\r\n    public static FixedLiteralLengthTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n        let i, il;\r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] =\r\n            (i <= 143) ? 8 :\r\n            (i <= 255) ? 9 :\r\n            (i <= 279) ? 7 :\r\n            8;\r\n        }\r\n        return buildHuffmanTable(lengths)\r\n    })();\r\n\r\n    public static FixedDistanceTable = (() => {\r\n        let lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n        let i, il;\r\n      \r\n        for (i = 0, il = lengths.length; i < il; ++i) {\r\n          lengths[i] = 5;\r\n        }\r\n      \r\n        return buildHuffmanTable(lengths);\r\n    })();\r\n\r\n    constructor (input: Uint8Array | Array<number>, ip?: number, opt_buffersize?: number) {\r\n         /** @type {!Array.<(Array|Uint8Array)>} */\r\n        this.blocks = [];\r\n        /** @type {number} block size. */\r\n        this.bufferSize =\r\n            opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\r\n        /** @type {!number} total output buffer pointer. */\r\n        this.totalpos = 0;\r\n        /** @type {!number} input buffer pointer. */\r\n        this.ip = ip === void 0 ? 0 : ip;\r\n        /** @type {!number} bit stream reader buffer. */\r\n        this.bitsbuf = 0;\r\n        /** @type {!number} bit stream reader buffer size. */\r\n        this.bitsbuflen = 0;\r\n        /** @type {!(Array|Uint8Array)} input buffer. */\r\n        this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n        /** @type {!(Uint8Array|Array)} output buffer. */\r\n        this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n        /** @type {!number} output buffer pointer. */\r\n        this.op = 0;\r\n        /** @type {boolean} is final block flag. */\r\n        this.bfinal = false;\r\n        /** @type {number} uncompressed block length. */\r\n        this.blockLength =0;\r\n        /** @type {boolean} resize flag for memory size optimization. */\r\n        this.resize = false;\r\n        /** @type {Array} */\r\n        this.litlenTable = [];\r\n        /** @type {Array} */\r\n        this.distTable = [];\r\n        /** @type {number} */\r\n        this.sp = 0; // stream pointer\r\n        /** @type {RawInflateStream.Status} */\r\n        this.status = RawInflateStream.Status.INITIALIZED;\r\n        /** @type {!number} */\r\n        this.ip_ = 0;\r\n        /** @type {!number} */\r\n        this.bitsbuflen_ = 0;\r\n        /** @type {!number} */\r\n        this.bitsbuf_ = 0;\r\n        this.currentBlockType = RawInflateStream.BlockType.FIXED;\r\n    }\r\n\r\n    public decompress(newInput: Uint8Array | Array<number>, ip: any) {\r\n        /** @type {boolean} */\r\n        let stop = false;\r\n      \r\n        if (newInput !== void 0) {\r\n          this.input = newInput;\r\n        }\r\n      \r\n        if (ip !== void 0) {\r\n          this.ip = ip;\r\n        }\r\n      \r\n        // decompress\r\n        while (!stop) {\r\n          switch (this.status) {\r\n            // block header\r\n            case RawInflateStream.Status.INITIALIZED:\r\n            case RawInflateStream.Status.BLOCK_HEADER_START:\r\n              if (this.readBlockHeader() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n            // block body\r\n            case RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\r\n            case RawInflateStream.Status.BLOCK_BODY_START:\r\n              switch(this.currentBlockType) {\r\n                case RawInflateStream.BlockType.UNCOMPRESSED:\r\n                  if (this.readUncompressedBlockHeader() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                case RawInflateStream.BlockType.FIXED:\r\n                  if (this.parseFixedHuffmanBlock() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                case RawInflateStream.BlockType.DYNAMIC:\r\n                  if (this.parseDynamicHuffmanBlock() < 0) {\r\n                    stop = true;\r\n                  }\r\n                  break;\r\n                default:\r\n                  break;\r\n              }\r\n              break;\r\n            // decode data\r\n            case RawInflateStream.Status.BLOCK_BODY_END:\r\n            case RawInflateStream.Status.DECODE_BLOCK_START:\r\n                switch(this.currentBlockType) {\r\n                    case RawInflateStream.BlockType.UNCOMPRESSED:\r\n                        if (this.parseUncompressedBlock() < 0) {\r\n                            stop = true;\r\n                        }\r\n                    break;\r\n                    case RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\r\n                    case RawInflateStream.BlockType.DYNAMIC:\r\n                        if (this.decodeHuffman() < 0) {\r\n                            stop = true;\r\n                        }\r\n                    break;\r\n                    default:\r\n                        break;\r\n            }\r\n              break;\r\n            case RawInflateStream.Status.DECODE_BLOCK_END:\r\n              if (this.bfinal) {\r\n                stop = true;\r\n              } else {\r\n                this.status = RawInflateStream.Status.INITIALIZED;\r\n              }\r\n              break;\r\n            default:\r\n              break;\r\n            }\r\n        }\r\n        return this.concatBuffer();\r\n    }\r\n\r\n    public readBlockHeader() {\r\n        /** @type {number} header */\r\n        let hdr;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_HEADER_START;\r\n      \r\n        this.save_();\r\n        hdr = this.readBits(3)\r\n        if (hdr < 0) {\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n      \r\n        // BFINAL\r\n        if (hdr & 0x1) {\r\n          this.bfinal = true;\r\n        }\r\n      \r\n        // BTYPE\r\n        hdr >>>= 1;\r\n        switch (hdr) {\r\n          case 0: // uncompressed\r\n            this.currentBlockType = RawInflateStream.BlockType.UNCOMPRESSED;\r\n            break;\r\n          case 1: // fixed huffman\r\n            this.currentBlockType = RawInflateStream.BlockType.FIXED;\r\n            break;\r\n          case 2: // dynamic huffman\r\n            this.currentBlockType = RawInflateStream.BlockType.DYNAMIC;\r\n            break;\r\n          default: // reserved or other\r\n            throw new Error('unknown BTYPE: ' + hdr);\r\n        }\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_HEADER_END;\r\n    }\r\n\r\n    public readBits(length: number) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {number} input and output byte. */\r\n        let octet;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < length) {\r\n          // input byte\r\n          if (input.length <= ip) {\r\n            return -1;\r\n          }\r\n          octet = input[ip++];\r\n      \r\n          // concat octet\r\n          bitsbuf |= octet << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // output byte\r\n        octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n        bitsbuf >>>= length;\r\n        bitsbuflen -= length;\r\n      \r\n        this.bitsbuf = bitsbuf;\r\n        this.bitsbuflen = bitsbuflen;\r\n        this.ip = ip;\r\n      \r\n        return octet;\r\n    }\r\n\r\n    public readCodeByTable(table: Array<number> | Uint8Array) {\r\n        let bitsbuf = this.bitsbuf;\r\n        let bitsbuflen = this.bitsbuflen;\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        /** @type {!(Array|Uint8Array)} huffman code table */\r\n        let codeTable = table[0];\r\n        /** @type {number} */\r\n        let maxCodeLength = table[1];\r\n        /** @type {number} input byte */\r\n        let octet;\r\n        /** @type {number} code length & code (16bit, 16bit) */\r\n        let codeWithLength;\r\n        /** @type {number} code bits length */\r\n        let codeLength;\r\n      \r\n        // not enough buffer\r\n        while (bitsbuflen < maxCodeLength) {\r\n          if (input.length <= ip) {\r\n            return -1;\r\n          }\r\n          octet = input[ip++];\r\n          bitsbuf |= octet << bitsbuflen;\r\n          bitsbuflen += 8;\r\n        }\r\n      \r\n        // read max length\r\n        codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n        codeLength = codeWithLength >>> 16;\r\n      \r\n        if (codeLength > bitsbuflen) {\r\n          throw new Error('invalid code length: ' + codeLength);\r\n        }\r\n      \r\n        this.bitsbuf = bitsbuf >> codeLength;\r\n        this.bitsbuflen = bitsbuflen - codeLength;\r\n        this.ip = ip;\r\n      \r\n        return codeWithLength & 0xffff;\r\n    }\r\n    public readUncompressedBlockHeader() {\r\n        /** @type {number} block length */\r\n        let len;\r\n        /** @type {number} number for check block length */\r\n        let nlen;\r\n      \r\n        let input = this.input;\r\n        let ip = this.ip;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        if (ip + 4 >= input.length) {\r\n          return -1;\r\n        }\r\n      \r\n        len = input[ip++] | (input[ip++] << 8);\r\n        nlen = input[ip++] | (input[ip++] << 8);\r\n      \r\n        // check len & nlen\r\n        if (len === ~nlen) {\r\n          throw new Error('invalid uncompressed block header: length verify');\r\n        }\r\n      \r\n        // skip buffered header bits\r\n        this.bitsbuf = 0;\r\n        this.bitsbuflen = 0;\r\n      \r\n        this.ip = ip;\r\n        this.blockLength = len;\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n    }\r\n\r\n    public parseUncompressedBlock() {\r\n        let input = this.input;\r\n        let ip = this.ip;\r\n        let output = this.output;\r\n        let op = this.op;\r\n        let len = this.blockLength;\r\n      \r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n      \r\n        // copy\r\n        // XXX: とりあえず素直にコピー\r\n        while (len--) {\r\n          if (op === output.length) {\r\n            output = this.expandBuffer({fixRatio: 2});\r\n          }\r\n      \r\n          // not enough input buffer\r\n          if (ip >= input.length) {\r\n            this.ip = ip;\r\n            this.op = op;\r\n            this.blockLength = len + 1; // コピーしてないので戻す\r\n            return -1;\r\n          }\r\n      \r\n          output[op++] = input[ip++];\r\n        }\r\n      \r\n        if (len < 0) {\r\n          this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n        }\r\n      \r\n        this.ip = ip;\r\n        this.op = op;\r\n      \r\n        return 0;\r\n    }\r\n\r\n    public parseFixedHuffmanBlock() {\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        this.litlenTable = RawInflateStream.FixedLiteralLengthTable;\r\n        this.distTable = RawInflateStream.FixedDistanceTable;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n      \r\n        return 0;\r\n    }\r\n\r\n    public save_() {\r\n        this.ip_ = this.ip;\r\n        this.bitsbuflen_ = this.bitsbuflen;\r\n        this.bitsbuf_ = this.bitsbuf;\r\n    }\r\n\r\n    public restore_() {\r\n        this.ip = this.ip_;\r\n        this.bitsbuflen = this.bitsbuflen_;\r\n        this.bitsbuf = this.bitsbuf_;\r\n    }\r\n\r\n    public parseDynamicHuffmanBlock() {\r\n        /** @type {number} number of literal and length codes. */\r\n        let hlit;\r\n        /** @type {number} number of distance codes. */\r\n        let hdist;\r\n        /** @type {number} number of code lengths. */\r\n        let hclen;\r\n        /** @type {!(Uint8Array|Array)} code lengths. */\r\n        let codeLengths =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflateStream.Order.length);\r\n        /** @type {!Array} code lengths table. */\r\n        let codeLengthsTable;\r\n        /** @type {!(Uint32Array|Array)} literal and length code lengths. */\r\n        let litlenLengths;\r\n        /** @type {!(Uint32Array|Array)} distance code lengths. */\r\n        let distLengths;\r\n      \r\n        this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n      \r\n        this.save_();\r\n        hlit = this.readBits(5) + 257;\r\n        hdist = this.readBits(5) + 1;\r\n        hclen = this.readBits(4) + 4;\r\n        if (hlit < 0 || hdist < 0 || hclen < 0) {\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n        const parseDynamicHuffmanBlockImpl = () => {\r\n          /** @type {number} */\r\n          let bits;\r\n          let code;\r\n          let prev = 0;\r\n          let repeat;\r\n          /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n          let lengthTable;\r\n          /** @type {number} loop counter. */\r\n          let i;\r\n          /** @type {number} loop limit. */\r\n          let il;\r\n      \r\n          // decode code lengths\r\n          for (i = 0; i < hclen; ++i) {\r\n            bits = this.readBits(3);\r\n            if ((bits) < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            codeLengths[RawInflateStream.Order[i]] = bits;\r\n          }\r\n      \r\n          // decode length table\r\n          codeLengthsTable = buildHuffmanTable(codeLengths);\r\n          lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n          for (i = 0, il = hlit + hdist; i < il;) {\r\n            code = this.readCodeByTable(codeLengthsTable);\r\n            if (code < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            switch (code) {\r\n              case 16:\r\n                bits = this.readBits(2);\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 3 + bits;\r\n                while (repeat--) { lengthTable[i++] = prev; }\r\n                break;\r\n              case 17:\r\n                bits = this.readBits(3)\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 3 + bits;\r\n                while (repeat--) { lengthTable[i++] = 0; }\r\n                prev = 0;\r\n                break;\r\n              case 18:\r\n                bits = this.readBits(7)\r\n                if (bits < 0) {\r\n                  throw new Error('not enough input');\r\n                }\r\n                repeat = 11 + bits;\r\n                while (repeat--) { lengthTable[i++] = 0; }\r\n                prev = 0;\r\n                break;\r\n              default:\r\n                lengthTable[i++] = code;\r\n                prev = code;\r\n                break;\r\n            }\r\n          }\r\n      \r\n          // literal and length code\r\n          litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);\r\n      \r\n          // distance code\r\n          distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);\r\n      \r\n          this.litlenTable = USE_TYPEDARRAY\r\n            ? buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n            : buildHuffmanTable(lengthTable.slice(0, hlit));\r\n          this.distTable = USE_TYPEDARRAY\r\n            ? buildHuffmanTable(lengthTable.subarray(hlit))\r\n            : buildHuffmanTable(lengthTable.slice(hlit));\r\n        }\r\n        try {\r\n            parseDynamicHuffmanBlockImpl();\r\n          } catch(e) {\r\n            this.restore_();\r\n            return -1;\r\n        }\r\n        this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n        return 0;\r\n    }\r\n\r\n    public decodeHuffman() {\r\n        let output = this.output;\r\n        let op = this.op;\r\n      \r\n        /** @type {number} huffman code. */\r\n        let code;\r\n        /** @type {number} table index. */\r\n        let ti;\r\n        /** @type {number} huffman code distination. */\r\n        let codeDist;\r\n        /** @type {number} huffman code length. */\r\n        let codeLength;\r\n      \r\n        let litlen = this.litlenTable;\r\n        let dist = this.distTable;\r\n      \r\n        let olength = output.length;\r\n        let bits;\r\n      \r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n      \r\n        while (true) {\r\n          this.save_();\r\n      \r\n          code = this.readCodeByTable(litlen);\r\n          if (code < 0) {\r\n            this.op = op;\r\n            this.restore_();\r\n            return -1;\r\n          }\r\n      \r\n          if (code === 256) {\r\n            break;\r\n          }\r\n      \r\n          // literal\r\n          if (code < 256) {\r\n            if (op === olength) {\r\n              output = this.expandBuffer();\r\n              olength = output.length;\r\n            }\r\n            output[op++] = code;\r\n      \r\n            continue;\r\n          }\r\n      \r\n          // length code\r\n          ti = code - 257;\r\n          codeLength = RawInflateStream.LengthCodeTable[ti];\r\n          if (RawInflateStream.LengthExtraTable[ti] > 0) {\r\n            bits = this.readBits(RawInflateStream.LengthExtraTable[ti]);\r\n            if (bits < 0) {\r\n              this.op = op;\r\n              this.restore_();\r\n              return -1;\r\n            }\r\n            codeLength += bits;\r\n          }\r\n      \r\n          // dist code\r\n          code = this.readCodeByTable(dist);\r\n          if (code < 0) {\r\n            this.op = op;\r\n            this.restore_();\r\n            return -1;\r\n          }\r\n          codeDist = RawInflateStream.DistCodeTable[code];\r\n          if (RawInflateStream.DistExtraTable[code] > 0) {\r\n            bits = this.readBits(RawInflateStream.DistExtraTable[code]);\r\n            if (bits < 0) {\r\n              this.op = op;\r\n              this.restore_();\r\n              return -1;\r\n            }\r\n            codeDist += bits;\r\n          }\r\n      \r\n          // lz77 decode\r\n          if (op + codeLength >= olength) {\r\n            output = this.expandBuffer();\r\n            olength = output.length;\r\n          }\r\n      \r\n          while (codeLength--) {\r\n            output[op] = output[(op++) - codeDist];\r\n          }\r\n      \r\n          // break\r\n          if (this.ip === this.input.length) {\r\n            this.op = op;\r\n            return -1;\r\n          }\r\n        }\r\n      \r\n        while (this.bitsbuflen >= 8) {\r\n          this.bitsbuflen -= 8;\r\n          this.ip--;\r\n        }\r\n      \r\n        this.op = op;\r\n        this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n    }\r\n\r\n    public expandBuffer(opt_param?: any) {\r\n        /** @type {!(Array|Uint8Array)} store buffer. */\r\n        let buffer;\r\n        /** @type {number} expantion ratio. */\r\n        let ratio = (this.input.length / this.ip + 1) | 0;\r\n        /** @type {number} maximum number of huffman code. */\r\n        let maxHuffCode;\r\n        /** @type {number} new output buffer size. */\r\n        let newSize;\r\n        /** @type {number} max inflate size. */\r\n        let maxInflateSize;\r\n      \r\n        let input = this.input;\r\n        let output = this.output;\r\n      \r\n        if (opt_param) {\r\n          if (typeof opt_param.fixRatio === 'number') {\r\n            ratio = opt_param.fixRatio;\r\n          }\r\n          if (typeof opt_param.addRatio === 'number') {\r\n            ratio += opt_param.addRatio;\r\n          }\r\n        }\r\n      \r\n        // calculate new buffer size\r\n        if (ratio < 2) {\r\n          maxHuffCode =\r\n            (input.length - this.ip) / this.litlenTable[2];\r\n          maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n          newSize = maxInflateSize < output.length ?\r\n            output.length + maxInflateSize :\r\n            output.length << 1;\r\n        } else {\r\n          newSize = output.length * ratio;\r\n        }\r\n      \r\n        // buffer expantion\r\n        if (USE_TYPEDARRAY) {\r\n          buffer = new Uint8Array(newSize);\r\n          buffer.set(output);\r\n        } else {\r\n          buffer = output;\r\n        }\r\n      \r\n        this.output = buffer;\r\n      \r\n        return this.output;\r\n      };\r\n      \r\n      public concatBuffer() {\r\n        /** @type {!(Array|Uint8Array)} output buffer. */\r\n        let buffer;\r\n        /** @type {number} */\r\n        let op = this.op;\r\n        /** @type {Uint8Array} */\r\n        let tmp;\r\n      \r\n        if (this.resize) {\r\n          if (USE_TYPEDARRAY) {\r\n            buffer = new Uint8Array((<Uint8Array>this.output).subarray(this.sp, op));\r\n          } else {\r\n            buffer = this.output.slice(this.sp, op);\r\n          }\r\n        } else {\r\n          buffer =\r\n            USE_TYPEDARRAY ? (<Uint8Array>this.output).subarray(this.sp, op) : this.output.slice(this.sp, op);\r\n        }\r\n      \r\n        this.sp = op;\r\n      \r\n        // compaction\r\n        if (op > RawInflateStream.MaxBackwardLength + this.bufferSize) {\r\n          this.op = this.sp = RawInflateStream.MaxBackwardLength;\r\n          if (USE_TYPEDARRAY) {\r\n            tmp = /** @type {Uint8Array} */(this.output);\r\n            this.output = new Uint8Array(this.bufferSize + RawInflateStream.MaxBackwardLength);\r\n            this.output.set(tmp.subarray(op - RawInflateStream.MaxBackwardLength, op));\r\n          } else {\r\n            this.output = this.output.slice(op - RawInflateStream.MaxBackwardLength);\r\n          }\r\n        }\r\n        return buffer;\r\n      }\r\n}\r\n","import { Adler32 as rAdler32, Alder as rAdler} from './adler32';\r\nimport { RawDeflate as rRawDeflate} from './rawdeflate';\r\nimport { CRC32 as rCRC32 } from './crc32';\r\nimport { Heap as rHeap } from './heap';\r\nimport { Huffman as rHuffman } from './huffman';\r\nimport { Zip as rZip } from './zip';\r\nimport { RawInflate as rRawInflate } from './rawinflate';\r\nimport { RawInflateStream as rRawInflateStream } from './rawinflate_stream';\r\n\r\nexport namespace ZlibT {\r\n    export const Adler32 = rAdler32;\r\n    export class Alder extends rAdler {};\r\n    export class RawDeflate extends rRawDeflate {};\r\n    export class CRC32 extends rCRC32 {};\r\n    export class Heap extends rHeap{};\r\n    export class RawInflateStream extends rRawInflateStream{};\r\n    export const CompressionMethod = {\r\n        DEFLATE: 8,\r\n        RESERVED: 15\r\n    };\r\n    export class Zip extends rZip {};\r\n    export class RawInflate extends rRawInflate {};\r\n    \r\n    export class Huffman extends rHuffman{}; \r\n}\r\n"],"sourceRoot":""}